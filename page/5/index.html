<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=z20lYmACQgemxcrzNk1C8Q"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'z20lYmACQgemxcrzNk1C8Q');
</script>
<!-- End Google Analytics -->

  
  <title>又是元气满满的一天</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="记录总结">
<meta property="og:type" content="website">
<meta property="og:title" content="又是元气满满的一天">
<meta property="og:url" content="https://energygreek.github.io/page/5/index.html">
<meta property="og:site_name" content="又是元气满满的一天">
<meta property="og:description" content="记录总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="greek_soon@hotmail.com">
<meta property="article:tag" content="c&#x2F;c++">
<meta property="article:tag" content=" Linux日常">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/" title="又是元气满满的一天">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="又是元气满满的一天" type="application/atom+xml">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">又是元气满满的一天</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://energygreek.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-binary-tree-traversal" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/binary-tree-traversal/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T11:01:54.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/18/binary-tree-traversal/">binary tree traversal</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><p>二叉树的父节点最多有2个子节点，如果二叉树的所有父节点没有节点或者有2个节点，那么叫完全二叉树</p>
<h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p>二叉树有4中遍历方式： 前序遍历， 中序， 后序， 以及层序  </p>
<p>前三种可以对比着看，区别在于父节点先被访问的顺序，这里的先后都是相对于同一个树而言。 这里的访问意思是访问其值， 例如打印节点的数据：  </p>
<ul>
<li>前序遍历， 先父节点，再左子节点，最后是右子节点 </li>
<li>中序遍历， 先左子节点， 再父节点， 最后是右子节点</li>
<li>中序遍历， 先左子节点， 再右子节点 ，最后父节点</li>
</ul>
<p>可见，都是先左子节点后右子节点  </p>
<p>而层序遍历是从上往下，广度优先</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>若有以下二叉树，则遍历结果</p>
<pre class="mermaid">graph BT
    A[1] --> B[0]
    C[2] --> B
    D[3] --> A
    E[4] --> A
    F[5] --> C
    G[6] --> C
    H[7] --> D
    I[8] --> D
    J[9] --> E</pre>

<p>层序: 0 1 2 3 4 5 6 7 8 9</p>
<p>先序: <u>0</u> 1 <u>3</u> 7 8 4 9 2 5 <u>6</u><br>中序: 7 <u>3</u> 8 1 9 4 <u>0</u> 5 2 <u>6</u><br>后序: 7 8 <u>3</u> 9 4 1 5 <u>6</u> 2 <u>0</u>  </p>
<p>注意下划线，即036组成的一个树， 可以证实上面的总结  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现前三种遍历都有2种方式， 递归和使用stack</p>
<p>节点数据结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Node</span>:</span></span><br><span class="line">    self.item</span><br><span class="line">    self.lchild</span><br><span class="line">    self.rchild</span><br></pre></td></tr></table></figure>

<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>前序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">front_recursion</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    print(root.item)</span><br><span class="line">    <span class="keyword">if</span> root.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.lchild)</span><br><span class="line">    <span class="keyword">if</span> root.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.rchild)</span><br></pre></td></tr></table></figure>

<p>中序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Middle_recursion</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.lchild)</span><br><span class="line">    print(root.item)</span><br><span class="line">    <span class="keyword">if</span> root.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.rchild)</span><br></pre></td></tr></table></figure>

<p>后序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Middle_recursion</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.lchild)</span><br><span class="line">    <span class="keyword">if</span> root.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.rchild)</span><br><span class="line">    print(root.item)</span><br></pre></td></tr></table></figure>

<h3 id="stack实现"><a href="#stack实现" class="headerlink" title="stack实现"></a>stack实现</h3><p>前序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Front_stack</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    stack = []</span><br><span class="line">    Node = root</span><br><span class="line">    stack.append(Node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Node <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">while</span> Node:</span><br><span class="line">			<span class="comment"># 访问和入栈的顺序顺序是先父节点后左节点</span></span><br><span class="line">            print(Node.item)</span><br><span class="line">            <span class="comment"># 父节点入栈</span></span><br><span class="line">            stack.append(Node.lchild)</span><br><span class="line">            <span class="comment"># 深度优先，找最左节点，下个循环就是先访问父节点后左子节点</span></span><br><span class="line">            Node = Node.lchild</span><br><span class="line">        <span class="comment"># 这里需要好好体会，父节点和左子节点已经访问过，只剩下右节点</span></span><br><span class="line">        <span class="comment"># 所以就是先左后右</span></span><br><span class="line">        Node = stack.pop()</span><br><span class="line">        Node = Node.rchild</span><br></pre></td></tr></table></figure>

<p>中序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Middle_stack</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    stack = []</span><br><span class="line">    Node = root</span><br><span class="line">    stack.append(Node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Node <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">while</span> Node:</span><br><span class="line">            <span class="comment"># 父节点入栈</span></span><br><span class="line">            <span class="comment"># 左子节点入栈</span></span><br><span class="line">            <span class="comment"># 但都不访问，因为压栈顺序是先父后左子，到出栈的时候再访问</span></span><br><span class="line">            stack.append(Node.lchild)</span><br><span class="line">            Node = Node.lchild</span><br><span class="line"></span><br><span class="line">        Node = stack.pop()</span><br><span class="line">        <span class="comment"># 找到最左子节点了，开始出栈，所以肯定是先出左节点， 然后再出栈之后就是父节点</span></span><br><span class="line">        print(Node.item)</span><br><span class="line">        <span class="comment"># 最后就是右节点， 回到第一个while 继续找右子树的最左节点</span></span><br><span class="line">        Node = Node.rchild</span><br></pre></td></tr></table></figure>

<p>后序的stack比较复杂</p>
<p>还有一个比较简单的先序stack</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Front_stack</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        Node = stack.pop()</span><br><span class="line">        print(Node.item)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># stack 先进后出，所以先压右节点</span></span><br><span class="line">        <span class="keyword">if</span> Node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(Node.rchild)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> Node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(Node.lchild)</span><br></pre></td></tr></table></figure>

<p>层序遍历,是广度优先的一种方式，所以使用到queue</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Layer_queue</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="comment"># 取前面的</span></span><br><span class="line">        Node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        print(Node.item)</span><br><span class="line">        <span class="keyword">if</span> Node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(Node.lchild)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> Node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(Node.rchild)</span><br></pre></td></tr></table></figure>

<h3 id="后序栈遍历"><a href="#后序栈遍历" class="headerlink" title="后序栈遍历"></a>后序栈遍历</h3><p>后序遍历的顺序是先左子后右子，最后才是父节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1. 同样先找到最左边的节点，父节点和左子节点入栈</span></span><br><span class="line"><span class="string">2. 找到最后一个左子节点之后，判断栈顶的节点，出栈顺序是先左子后父节点，所以只需要判断右子节点的情况：</span></span><br><span class="line"><span class="string">   如果栈顶节点的右子节点为空，直接打印栈顶节点。 如果栈顶节点的右子节点是上一个出栈的节点，那么说明已经访问到了右子节点，可以继续打印父节点  </span></span><br><span class="line"><span class="string">   如果栈顶的右子节点不为空也不是上一个访问的节点，所以要先去访问右子树， 将右子节点入栈，退出循环，执行第一步</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back_stack</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    stack = []</span><br><span class="line">    Tag = <span class="literal">None</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        Node = stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> Node.lchild:</span><br><span class="line">            stack.append(Node.lchild)</span><br><span class="line">            Node = Node.lchild</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            Node = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> Tag == Node.rchild <span class="keyword">or</span> Node.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                Node = stack.pop()</span><br><span class="line">                print(Node.item)</span><br><span class="line">                Tag = Node</span><br><span class="line">            <span class="keyword">elif</span> Node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(Node.rchild)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/18/binary-tree-traversal/" data-id="clsbmbv38001obwoph62g5ams" data-title="binary tree traversal" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker-overlay-filesystem" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/docker-overlay-filesystem/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T01:38:41.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/18/docker-overlay-filesystem/">docker overlay filesystem</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="overlay-是docker使用的文件系统，具有分层的特点"><a href="#overlay-是docker使用的文件系统，具有分层的特点" class="headerlink" title="overlay 是docker使用的文件系统，具有分层的特点"></a>overlay 是docker使用的文件系统，具有分层的特点</h1><p>docker使用的文件系统经过很多变化，而且各发行版可能不同。<br>执行<code>docker info</code> 查看当前使用的是overlay2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info | grep -i storage                                                                                                                                              </span><br><span class="line"> Storage Driver: overlay2</span><br></pre></td></tr></table></figure>

<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>除了 overlay，类似有rootfs， aufs （ubuntu）， devicemapper（centos），不够成熟的btrfs</p>
<p>他们都有2个目的：  </p>
<ol>
<li>提供不含内核的文件系统（rootfs）即容器, 在内核之上。这是docker 最有价值的地方，就是无论在那里运行docker， 容器里的环境都是一致的</li>
<li>提供分层</li>
</ol>
<h2 id="overlay的优势"><a href="#overlay的优势" class="headerlink" title="overlay的优势"></a>overlay的优势</h2><ol>
<li>page caching， 可以在多个不同实例之间共享</li>
<li>写时复制， 只有执行write操作时， 会将lower layer 的文件复制到container层</li>
<li>不同层之间，相同文件使用硬连接， 节省inode 和 大小</li>
</ol>
<p>写时复制 copy-up 会导致第一次写时造成延迟，特别是大文件，拷贝起来费时。 但第二次就不会延时， 而且overlay2 有caching， 相比其它文件系统，更减少延时</p>
<h2 id="overlay的问题"><a href="#overlay的问题" class="headerlink" title="overlay的问题"></a>overlay的问题</h2><ol>
<li>实现不够完全， 例如没有实现uname </li>
<li>先只读打开一个文件 open（read）， 再读写打开相同文件open（write）， 两个fd 会对应2个不同文件， 第一个对应的lower的文件，第二个造成写时复制，对应容器里的文件。 <ul>
<li>规避方法是先执行touch 操作。 现实的例子是 yum 需要安装yum-plugin-ovl。 但这个只有7.2才支持， 之前的话就需要先<code>touch /var/lib/rpm/*</code></li>
</ul>
</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>使用ssd </li>
<li>对于写操作比较多的目录， 使用映射文件。这样跳过了overlay的复杂操作，直接使用主机的文件系统。</li>
</ol>
<h2 id="分层介绍"><a href="#分层介绍" class="headerlink" title="分层介绍"></a>分层介绍</h2><p>我理解就是将分离的多个目录挂载到一起的技术。<br>例如对docker 容器的文件进行增删改后，再commit， 会多一层layer。<br>再当docker 容器启动时，会自动挂载多层layer。<br><strong><em>组织</em></strong>： overlay对运行的实例通过元数据组织文件， 是否是link文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls 04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;</span><br><span class="line">diff  link  lower  merged  work</span><br></pre></td></tr></table></figure>

<h3 id="手动mount的例子"><a href="#手动mount的例子" class="headerlink" title="手动mount的例子"></a>手动mount的例子</h3><ol>
<li>原本目录，文件都分散在不同目录ABC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── aa</span><br><span class="line">│   └── a.txt</span><br><span class="line">├── B</span><br><span class="line">│   ├── a.txt</span><br><span class="line">│   └── b.txt</span><br><span class="line">├── C</span><br><span class="line">│   └── c.txt</span><br><span class="line">└── worker</span><br><span class="line">    └── work [error opening dir]</span><br></pre></td></tr></table></figure></li>
<li>overlay 挂载到/tmp/test目录 <code>sudo mount -t overlay overlay -o lowerdir=A:B,upperdir=C,workdir=worker /tmp/test/</code></li>
<li>查看test目录 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;tmp&#x2F;test&#x2F;</span><br><span class="line">├── aa</span><br><span class="line">├── a.txt</span><br><span class="line">├── b.txt</span><br><span class="line">└── c.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount  | grep &#39;overlay&#39;</span><br><span class="line">overlay on &#x2F;tmp&#x2F;test type overlay (rw,relatime,lowerdir&#x3D;A:B,upperdir&#x3D;C,workdir&#x3D;worker)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="overlay的增删改"><a href="#overlay的增删改" class="headerlink" title="overlay的增删改"></a>overlay的增删改</h3><p>当运行docker容器时查看挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">overlay on &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;merged type overlay </span><br><span class="line">(rw,relatime,</span><br><span class="line">	lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;B74PWZCBMRCWXFH5UL2ZXB5WEU:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;WNHICVPVSDNUGSCZW435TPSMOK,</span><br><span class="line">	upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;diff,</span><br><span class="line">	workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;work</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>docker 将镜像的文件挂载为只读， 将容器层挂载为可读可写。 文件系统可以分为2部分<br>upper（容器层） + lower （镜像层）</p>
<ul>
<li>当在容器里执行写时， 如果文件不存在， 会依次遍历lower。如果都不存在就会在upper层创建文件</li>
<li>读也相同</li>
<li>删除时会创建一个without 来隐藏， 这是为什么即使删除容器里的文件， 镜像还是会增大。 </li>
<li>删除目录情况也差不多</li>
</ul>
<p>似乎很奇怪，为什么多了一个workdir,  据说这个目录总是空的，为了实现原子操作添加和删除文件</p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>在修改容器后， 容器系统会多一层， 里面包含了修改的文件，以及删除后生成的without文件， 然后生成镜像</p>
<p>但对于以下特殊目录文件不会提交， 因为这些文件是运行时docker 要根据用户配置进行修改的。  </p>
<ol>
<li>/etc/hostname </li>
<li>/etc/hosts </li>
<li>/etc/resov.conf</li>
</ol>
<p>例如docker 的link选项，会在容器的hosts 文件里定义对应的容器名-&gt;容器ip</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/18/docker-overlay-filesystem/" data-id="clsbmbv3h0026bwopd6ffe8t2" data-title="docker overlay filesystem" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/filesystem/" rel="tag">filesystem</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-python-package-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/16/python-package-1/" class="article-date">
  <time class="dt-published" datetime="2020-11-16T02:53:51.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/16/python-package-1/">python package2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="python-安装方式有2种-pip-和-easy-install"><a href="#python-安装方式有2种-pip-和-easy-install" class="headerlink" title="python 安装方式有2种 pip 和 easy_install"></a>python 安装方式有2种 pip 和 easy_install</h1><p>easy_install 是随setuptools 附带的安装工具<br>pip 是后出的替 代setuptools 的工具</p>
<h2 id="支持情况"><a href="#支持情况" class="headerlink" title="支持情况"></a>支持情况</h2><p>pip 支持新的sdist标准，包括whl二进制包和源码tar包，支持安装和卸载<br>easy_install 支持老的 Egg  格式</p>
<h2 id="总结一句话"><a href="#总结一句话" class="headerlink" title="总结一句话"></a>总结一句话</h2><p>使用pip 不要使用easy_install</p>
<h2 id="包-Platform-tags"><a href="#包-Platform-tags" class="headerlink" title="包 Platform tags"></a>包 Platform tags</h2><p>linux的包的tags有好几个，向后兼容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">manylinux1 支持 x86_64 i686</span><br><span class="line">manylinux2010 支持 x86_64 i686</span><br><span class="line">manylinux2014 支持 x86_64 i686 arm ppc</span><br></pre></td></tr></table></figure>
<p>manylinux2010 取代了 manylinux1, 而且已经EOL,  所以尽早使用manylinux2014</p>
<h2 id="使用pip打包"><a href="#使用pip打包" class="headerlink" title="使用pip打包"></a>使用pip打包</h2><p>先生成 requirements.txt, 手动加上自己的包myapp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip list &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"># 打包命令</span><br><span class="line">python -m pip wheel --wheel-dir&#x3D;.&#x2F;local&#x2F;wheels -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>查看生成的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd local&#x2F;wheels</span><br><span class="line">Bootstrap_Flask-1.5.1-py2.py3-none-any.whl  Flask_SQLAlchemy-2.4.4-py2.py3-none-any.whl  Jinja2-2.11.2-py2.py3-none-any.whl                SQLAlchemy-1.3.20-cp38-cp38-manylinux2010_x86_64.whl</span><br><span class="line">click-7.1.2-py2.py3-none-any.whl            Flask_WTF-0.14.3-py2.py3-none-any.whl        MarkupSafe-1.1.1-cp38-cp38-manylinux1_x86_64.whl  Werkzeug-1.0.1-py2.py3-none-any.whl</span><br><span class="line">Flask-1.1.2-py2.py3-none-any.whl            itsdangerous-1.1.0-py2.py3-none-any.whl      myapp-0.1.dev0-py3-none-any.whl                   WTForms-2.3.3-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure>

<h2 id="使用pip-安装"><a href="#使用pip-安装" class="headerlink" title="使用pip 安装"></a>使用pip 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --no-index --find-links&#x3D;.&#x2F;local&#x2F;wheels -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="对于外部的包，需要本地安装"><a href="#对于外部的包，需要本地安装" class="headerlink" title="对于外部的包，需要本地安装"></a>对于外部的包，需要本地安装</h2><p>这个通常是在ci/cd上使用， 先把所有依赖拉到本地，就可以直接从本地的repo里下载依赖，离线安装</p>
<p>首先下载包的依赖，然后进行安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m pip download --destination-directory DIR -r requirements.txt</span><br><span class="line"></span><br><span class="line">python -m pip install --no-index --find-links&#x3D;DIR -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>pip和 whell 作为新的打包和安装方式，比较简单也支持多平台CPU, 推荐</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/16/python-package-1/" data-id="clsbmbv49003jbwop4d8c5crh" data-title="python package2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-advanced-marco-in-c" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/10/advanced-marco-in-c/" class="article-date">
  <time class="dt-published" datetime="2020-11-10T10:48:01.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/10/advanced-marco-in-c/">advanced marco in c</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>宏定义是在c/c++里特有的方式， 像变量一样， 又像模板编程一样， 但最常见的用法还是做头文件的唯一性保证  </p>
<p>在每一个头文件都套用这种格式，就可以避免多次引入头文件而导致的重复定义报错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILE_NAME</span></span><br><span class="line"><span class="meta">#def FILE_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> FILE_NAME</span></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>宏定义与变量、模板的最大区别在与处理的时期， 宏定义在预编译时处理， 而变量和模板函数则是在编译期处理。<br>查看预编译后的代码可以使用命令<code>gcc -E</code> 或者 <code>cpp</code>， 实际上是前者是调用了后者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       cpp - The C Preprocessor</span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>除了<code>#ifdef</code> 的用法，宏定义可以分两种类型，变量型和函数型</p>
<h3 id="变量型"><a href="#变量型" class="headerlink" title="变量型"></a>变量型</h3><p>这个最简单，就像使用变量一样，先define 然后再使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># marco.c</span><br><span class="line">#define BUFFER_SIZE 1024</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	foo &#x3D; (char *) malloc (BUFFER_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>gcc -E marco.c</code> 得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo &#x3D; (char *) malloc (1024);</span><br></pre></td></tr></table></figure>

<p>多行使用 ‘&#39; 来连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define GREETING_STR \</span><br><span class="line">  &quot;hello \</span><br><span class="line">world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意, 宏定义的定义不分前后， 也不像变量那样先定义再使用， 宏定义可以先使用后定义  </li>
</ul>
<p>以下两种方式的效果相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define GREETING_NAME &quot;wayou&quot;</span><br><span class="line"></span><br><span class="line">define GREETING &quot;hello,&quot; GREETING_NAME</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">printf(GREETING);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+define GREETING "hello," GREETING_NAME</span></span><br><span class="line"></span><br><span class="line">define GREETING_NAME "wayou"</span><br><span class="line"></span><br><span class="line"><span class="deletion">-define GREETING "hello," GREETING_NAME</span></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">printf(GREETING);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数型"><a href="#函数型" class="headerlink" title="函数型"></a>函数型</h3><p>函数类型的宏，可以像正常函数一样指定入参，入参需为逗号分隔合法的 C 字面量。<br>宏的参数必须要用括号包起来，否则当参数为表达式时，会出错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span><br><span class="line">  x &#x3D; min(a, b);          →  x &#x3D; ((a) &lt; (b) ? (a) : (b));</span><br><span class="line">  y &#x3D; min(1, 2);          →  y &#x3D; ((1) &lt; (2) ? (1) : (2));</span><br><span class="line">  z &#x3D; min(a + 28, *p);    →  z &#x3D; ((a + 28) &lt; (*p) ? (a + 28) : (*p));</span><br></pre></td></tr></table></figure>

<h3 id="宏定义字符串化"><a href="#宏定义字符串化" class="headerlink" title="宏定义字符串化"></a>宏定义字符串化</h3><p>当宏定义的参数被引号包起来时， 不会进行替换，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define foo(x) x, &quot;x&quot;</span><br><span class="line">foo(bar)        → bar, &quot;x&quot;</span><br></pre></td></tr></table></figure>

<p>加入需要将参数替换到字符串里， 可以使用’#’  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define WARN_IF(EXP) \</span><br><span class="line">do &#123; if (EXP) \</span><br><span class="line">        fprintf (stderr, &quot;Warning: &quot; #EXP &quot;\n&quot;); &#125; \</span><br><span class="line">while (0)</span><br><span class="line">WARN_IF (x &#x3D;&#x3D; 0);</span><br><span class="line">     → do &#123; if (x &#x3D;&#x3D; 0)</span><br><span class="line">           fprintf (stderr, &quot;Warning: &quot; &quot;x &#x3D;&#x3D; 0&quot; &quot;\n&quot;); &#125; while (0);</span><br></pre></td></tr></table></figure>

<p>而当 这里的x 也是宏定义时， 只有if里的x会替换， 字符串里的x则不会替换  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define X ( 1 - 1 )</span><br><span class="line">WARN_IF ( X &#x3D;&#x3D; 0);</span><br></pre></td></tr></table></figure>
<p>会被替换为  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123; if (( 1 - 1 ) &#x3D;&#x3D; 0) fprintf (</span><br><span class="line">stderr</span><br><span class="line">, &quot;Warning: &quot; &quot;X &#x3D;&#x3D; 0&quot; &quot;\n&quot;); &#125; while (0);</span><br></pre></td></tr></table></figure>

<h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>通过 ## 可将两个宏展开成一个，即将两者进行了拼接，宏拼接一般用在需要拼接的宏是来自宏参数的情况，<br>其他情况，大可直接将两个宏写在一起即可</p>
<p>当有以下情况时非常有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct command</span><br><span class="line">&#123;</span><br><span class="line">  char *name;</span><br><span class="line">  void (*function) (void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct command commands[] &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">&#123; &quot;quit&quot;, quit_command &#125;,</span><br><span class="line">&#123; &quot;help&quot;, help_command &#125;,</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define COMMAND(NAME)  &#123; #NAME, NAME ## _command &#125;</span><br><span class="line"></span><br><span class="line">struct command commands[] &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">COMMAND (quit),</span><br><span class="line">COMMAND (help),</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="不定参数和混合参数"><a href="#不定参数和混合参数" class="headerlink" title="不定参数和混合参数"></a>不定参数和混合参数</h3><p>宏定义也可以使用不定参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define eprintf(args…) fprintf (stderr, args)</span><br></pre></td></tr></table></figure>

<p>也可以使用混合参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define eprintf(format, args...) fprintf (stderr, format, args)</span><br></pre></td></tr></table></figure>
<p>这个可以常在格式化打印时用到， 例如 <code>spdlog</code> 库  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define SPDLOG_LOGGER_CALL(logger, level, ...)                                                                                             \</span><br><span class="line">    if (logger-&gt;should_log(level))                                                                                                         \</span><br><span class="line">    logger-&gt;log(spdlog::source_loc&#123;SPDLOG_FILE_BASENAME(__FILE__), __LINE__, SPDLOG_FUNCTION&#125;, level, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">#if SPDLOG_ACTIVE_LEVEL &lt;&#x3D; SPDLOG_LEVEL_TRACE</span><br><span class="line">#define SPDLOG_LOGGER_TRACE(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::trace, __VA_ARGS__)</span><br><span class="line">#define SPDLOG_TRACE(...) SPDLOG_LOGGER_TRACE(spdlog::default_logger_raw(), __VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define SPDLOG_LOGGER_TRACE(logger, ...) (void)0</span><br><span class="line">#define SPDLOG_TRACE(...) (void)0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if SPDLOG_ACTIVE_LEVEL &lt;&#x3D; SPDLOG_LEVEL_DEBUG</span><br><span class="line">#define SPDLOG_LOGGER_DEBUG(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::debug, __VA_ARGS__)</span><br><span class="line">#define SPDLOG_DEBUG(...) SPDLOG_LOGGER_DEBUG(spdlog::default_logger_raw(), __VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define SPDLOG_LOGGER_DEBUG(logger, ...) (void)0</span><br><span class="line">#define SPDLOG_DEBUG(...) (void)0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="重复和覆盖"><a href="#重复和覆盖" class="headerlink" title="重复和覆盖"></a>重复和覆盖</h2><p>这些是相似的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define FOUR (2 + 2)</span><br><span class="line">#define FOUR         (2    +    2)</span><br><span class="line">#define FOUR (2 &#x2F;* two *&#x2F; + 2)</span><br></pre></td></tr></table></figure>

<p>以下都是不同的宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define FOUR (2 + 2)</span><br><span class="line">#define FOUR ( 2+2 ) &#x2F;&#x2F; 空白位置不一样 </span><br><span class="line">#define FOUR (2 * 2) &#x2F;&#x2F; 宏的内容不一样</span><br><span class="line">#define FOUR(score,and,seven,years,ago) (2 + 2) &#x2F;&#x2F; 入参不一样</span><br></pre></td></tr></table></figure>

<p>对于使用了 #undef 注销过的宏，再次定义同名的宏时，要求新定义的宏不与老的相似。</p>
<p>而如果说一个已经存在的宏，并没有注销，重复定义时，如果相似，则新的定义会忽略，如果不相似，编译器会报警告同时使用新定义的宏。这允许在多个文件中定义同一个宏。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p> 可以查看更多<a href="https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html#Predefined-Macros" target="_blank" rel="noopener">内置宏定义</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/10/advanced-marco-in-c/" data-id="clsbmbv30001jbwop9v024koy" data-title="advanced marco in c" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-c/" rel="tag">c/c++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-python-package" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/10/python-package/" class="article-date">
  <time class="dt-published" datetime="2020-11-10T02:36:23.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/10/python-package/">python package</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="python-包的管理"><a href="#python-包的管理" class="headerlink" title="python 包的管理"></a>python 包的管理</h1><p>python 有 sdist 和 wheel 两种方式管理包：</p>
<p>sdist 是在 <code>python setup.py sdist</code>时产生的包，是一个源码压缩包，在安装时需要编译，所以环境依赖make和gcc<br>wheel 是在<code>python setup.py  bdist_wheel</code>是产生的whl 格式包</p>
<p>从命令都可以看出来sdist即source源码包， bdist 即binary二进制包  </p>
<p>sdist 由distutils、setuptools 定义和依赖的编译系统， 可以运行任意的代码<br>wheel 包为编译和安装时提供了简单的接口，里面包含了二进制的包，可以让安装者不需要知道编译体系,依赖wheel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wheel</span><br></pre></td></tr></table></figure>

<h2 id="两种包的打包命令"><a href="#两种包的打包命令" class="headerlink" title="两种包的打包命令"></a>两种包的打包命令</h2><p>前提是环境安装了setuptools和wheel, 且编写了setup.py文件如  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup,find_namespace_packages</span><br><span class="line"><span class="comment">#import pathlib</span></span><br><span class="line"><span class="comment">#import pkg_resources</span></span><br><span class="line"><span class="comment">#import os</span></span><br><span class="line"><span class="comment">#import sys</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.path.insert(0, os.path.join(</span></span><br><span class="line"><span class="comment">#    os.path.dirname(os.path.abspath(__file__)), 'src'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析文本文件</span></span><br><span class="line"><span class="comment">#with pathlib.Path('requirements.txt').open() as requirements_txt:</span></span><br><span class="line"><span class="comment">#    install_requires = [str(requirement) for requirement in pkg_resources.parse_requirements(requirements_txt) ]</span></span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">'myflask'</span>,</span><br><span class="line">      version=<span class="string">'1.3'</span>,</span><br><span class="line">      install_requires=[</span><br><span class="line">            <span class="string">'Bootstrap-Flask==1.4'</span>,</span><br><span class="line">            <span class="string">'Flask==1.1.2'</span>,</span><br><span class="line">            <span class="string">'Flask-Login==0.5.0'</span>,</span><br><span class="line">            <span class="string">'SQLAlchemy==1.3.18'</span>,</span><br><span class="line">            <span class="string">'Werkzeug==1.0.1'</span>,</span><br><span class="line">            <span class="string">'WTForms==2.3.1'</span></span><br><span class="line">          ],</span><br><span class="line">      entry_points=&#123;</span><br><span class="line">             <span class="string">'console_scripts'</span>:[</span><br><span class="line">                   <span class="string">'myflask=wsgi:main'</span></span><br><span class="line">                   ]</span><br><span class="line">            &#125;,</span><br><span class="line">      package_data = &#123;</span><br><span class="line">        <span class="string">''</span>: [<span class="string">'*.html'</span>],</span><br><span class="line">        <span class="string">''</span>: [<span class="string">'*.css'</span>],</span><br><span class="line">        <span class="string">''</span>: [<span class="string">'*.js'</span>],</span><br><span class="line">        <span class="string">''</span>: [<span class="string">'static/*'</span>],</span><br><span class="line">        <span class="string">''</span>: [<span class="string">'templates/*'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      py_modules=[<span class="string">'myflask'</span>],</span><br><span class="line">      packages=find_namespace_packages(),</span><br><span class="line">      zip_safe=<span class="literal">False</span>,</span><br><span class="line">      include_package_data=<span class="literal">True</span>,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>
<p>我这里定义了安装模块，myflask,可以被uwsgi 文件引入，方便管理， 同时也加入了很多html的静态文件， 是一个完整的网站  </p>
<ol>
<li><p>生成sdist包， 在项目目录执行<code>python setup.py sdist</code>，可以在sdit目录看到tar包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myflask &gt; ls dist                                                                                                                                                                                                      </span></span><br><span class="line">myflask-1.3.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成wheel包，在项目目录执行<code>python setup.py bdist_wheel</code>，可以在sdit目录看到whl包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># myflask &gt; ls dist</span><br><span class="line">myflask-1.3-py3-none-any.whl  myflask-1.3.tar.gz</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装命令相同，<code>pip install myflask-1.3.tar.gz</code> <code>pip instal myflask-1.3-py3-none-any.whl</code>。但过程不同</p>
<p>举例安装yarl 的源码包, 源码包需要编译，如果环境没有gcc,就会安装失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collecting yarl&lt;2.0,&gt;&#x3D;1.0 (from aiohttp&#x3D;&#x3D;3.6.2)</span><br><span class="line">  Downloading yarl-1.6.2.tar.gz (177kB)</span><br><span class="line">  Installing build dependencies: started</span><br><span class="line">  Installing build dependencies: finished with status &#39;done&#39;</span><br><span class="line">  Getting requirements to build wheel: started</span><br><span class="line">  Getting requirements to build wheel: finished with status &#39;done&#39;</span><br><span class="line">    Preparing wheel metadata: started</span><br><span class="line">    Preparing wheel metadata: finished with status &#39;done&#39;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  gcc -pthread -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I&#x2F;opt&#x2F;ha&#x2F;include&#x2F;python3.8 -c yarl&#x2F;_quoting_c.c -o build&#x2F;temp.linux-x86_64-3.8&#x2F;yarl&#x2F;_quoting_c.o</span><br><span class="line">  error: command &#39;gcc&#39; failed with exit status 1</span><br><span class="line">  ----------------------------------------</span><br><span class="line">  ERROR: Failed building wheel for yarl</span><br><span class="line">  Running setup.py clean for yarl</span><br><span class="line">Failed to build yarl</span><br></pre></td></tr></table></figure>

<p>此时，如果使用wheel包就不会出问题，但如果wheel包里面依赖了二进制文件，则需要区分cpu架构和系统了<br>我的myflask不依赖任何二进制文件，所以是none, 所有cpu和系统都可以安装  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myflask-1.3-py3-none-any.whl</span><br></pre></td></tr></table></figure>
<p>对于yarl不同， 在pypi.org 下载时，需要选择正确的包。或者选择源码包<code>yarl-1.6.2.tar.gz</code>来安装编译  </p>
<p>当然如果让pip选择在线安装就不需要考虑， 他会自动帮你寻找对应你系统的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Download files</span><br><span class="line"></span><br><span class="line">Download the file for your platform. If you&#39;re not sure which to choose, learn more about installing packages.</span><br><span class="line">Files for yarl, version 1.6.2</span><br><span class="line">Filename, size 	File type 	Python version 	Upload date 	Hashes</span><br><span class="line">yarl-1.6.2-cp36-cp36m-macosx_10_14_x86_64.whl (128.3 kB) 	Wheel 	cp36 	Oct 13, 2020 	View</span><br><span class="line">yarl-1.6.2-cp36-cp36m-manylinux1_i686.whl (293.5 kB) 	Wheel 	cp36 	Oct 13, 2020 	View</span><br><span class="line">yarl-1.6.2-cp36-cp36m-manylinux2014_aarch64.whl (294.5 kB) 	Wheel 	cp36 	Oct 13, 2020 	View</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">yarl-1.6.2.tar.gz (177.5 kB) 	Source 	None 	Oct 13, 2020 	View</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/10/python-package/" data-id="clsbmbv4b003obwopeoik2jd9" data-title="python package" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" rel="tag">包管理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-system-calls-method" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/09/system-calls-method/" class="article-date">
  <time class="dt-published" datetime="2020-11-09T08:13:11.000Z" itemprop="datePublished">2020-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/09/system-calls-method/">system calls method</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前学汇编发现教材和实际的有出入， 书上写的int, 但是汇编不通过，而gcc 反汇编的结果是调用syscall。<br>原来这是两种方式调用方式即： int  0x80 和 syscall  </p>
<p>除此之外还有一个名词是vdso,  很多elf文件会链接这个vdso库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldd a.out                                                                                                                                                                                                                   √ 19:03:30 </span><br><span class="line">	linux-vdso.so.1 (0x00007fffb3de0000)</span><br><span class="line">	libc.so.6 &#x3D;&gt; &#x2F;usr&#x2F;lib&#x2F;libc.so.6 (0x00007f5b48d4a000)</span><br><span class="line">	&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 &#x3D;&gt; &#x2F;usr&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f5b48f36000)</span><br></pre></td></tr></table></figure>

<h2 id="词汇说明"><a href="#词汇说明" class="headerlink" title="词汇说明"></a>词汇说明</h2><p><code>int 0x80</code> 即80中断， 是最老的系统函数调用方式<br><code>syscall/sysret</code> 是amd64 制定的标准， 也是目前的x86 64位的标准，即<code>amd64</code><br><code>sysenter/syssysexit</code> 是inter制定的x86 64位标准， 目前已被放弃<br><code>vdso</code> 是linux内核虚拟出的so, 实现了int 80 和 syscall，调用方式为 <code>vsyscall</code></p>
<h2 id="系统函数调用路径"><a href="#系统函数调用路径" class="headerlink" title="系统函数调用路径"></a>系统函数调用路径</h2><p>系统调用多被封装成库函数提供给应用程序调用，应用程序调用库函数后，由 glibc 库负责进入内核调用系统调用函数。<br>即<code>用户函数-&gt; glibc -&gt; 系统调用</code></p>
<h2 id="int-0x80"><a href="#int-0x80" class="headerlink" title="int 0x80"></a>int 0x80</h2><p>int 即是interrupt 中断， 0x80是IDT上注册的中断向量， 每个编号对应一个处理函数handle， linux的0x80的handle即是内核，即系统调用。<br>所以不同的系统设置的0x80的handle可能不同</p>
<p>调用方式：首先是将参数复制到寄存器， 参数包括系统调用编号和传入参数，然后执行 init  0x80<br>例如，以下的进程退出的系统调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">    s:</span><br><span class="line">        .ascii &quot;hello world\n&quot;</span><br><span class="line">        len &#x3D; . - s</span><br><span class="line">.text</span><br><span class="line">    .global _start</span><br><span class="line">    _start:</span><br><span class="line"></span><br><span class="line">        movl $4, %eax   &#x2F;* write system call number *&#x2F;</span><br><span class="line">        movl $1, %ebx   &#x2F;* stdout *&#x2F;</span><br><span class="line">        movl $s, %ecx   &#x2F;* the data to print *&#x2F;</span><br><span class="line">        movl $len, %edx &#x2F;* length of the buffer *&#x2F;</span><br><span class="line">        int $0x80</span><br><span class="line"></span><br><span class="line">        movl $1, %eax   &#x2F;* 退出的系统调用编号 *&#x2F;</span><br><span class="line">        movl $0, %ebx   &#x2F;* exit status *&#x2F;</span><br><span class="line">        int $0x80</span><br></pre></td></tr></table></figure>

<h2 id="vdos"><a href="#vdos" class="headerlink" title="vdos"></a>vdos</h2><p>vdos即 linux-vdso.so.1， 几乎很多elf 都会链接这个库，但其实他并不是真实存在的so文件，<br>而是由内核虚拟的文件，再映射到用户的进程来调用。</p>
<p>vdos  是对以下几个函数的实现，称作快速调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_gettimeofday 96 &#x2F;&#x2F;0x60</span><br><span class="line">#define __NR_time 201 &#x2F;&#x2F;0xc9</span><br><span class="line">#define __NR_clock_gettime 228 &#x2F;&#x2F;0xE4</span><br><span class="line">#define __NR_getcpu 309 &#x2F;&#x2F;0x135</span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>所以以上总结其实就3种方式， int ，syscall/sysret ， vdso</p>
<p>int 0x80 方式很慢，所以出现了syscall 即快速调用</p>
<p>执行区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 x86 保护模式中，处理 INT 中断指令时，CPU 首先从中断描述表 IDT 取出对应的门描述符，判断门描述符的种类，然后检查门描述符的级别 DPL 和 INT 指令调用者的级别 CPL，当 CPL&lt;&#x3D;DPL 也就是说 INT 调用者级别高于描述符指定级别时，才能成功调用，最后再根据描述符的内容，进行压栈、跳转、权限级别提升。内核代码执行完毕之后，调用 IRET 指令返回，IRET 指令恢复用户栈，并跳转会低级别的代码。</span><br><span class="line"></span><br><span class="line">其实，在发生系统调用，由 Ring3 进入 Ring0 的这个过程浪费了不少的 CPU 周期，例如，系统调用必然需要由 Ring3 进入 Ring0（由内核调用 INT 指令的方式除外，这多半属于 Hacker 的内核模块所为），权限提升之前和之后的级别是固定的，CPL 肯定是 3，而 INT 80 的 DPL 肯定也是 3，这样 CPU 检查门描述符的 DPL 和调用者的 CPL 就是完全没必要。正是由于如此，Intel x86 CPU 从 PII 300（Family 6，Model 3，Stepping 3）之后，开始支持新的系统调用指令 sysenter&#x2F;sysexit。sysenter 指令用于由 Ring3 进入 Ring0，SYSEXIT 指令用于由 Ring0 返回 Ring3。由于没有特权级别检查的处理，也没有压栈的操作，所以执行速度比 INT n&#x2F;IRET 快了不少。</span><br></pre></td></tr></table></figure>

<p>返回的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 Intel 的手册中，还提到了 sysenter&#x2F;sysexit 和 int n&#x2F;iret 指令的一个区别，那就是 sysenter&#x2F;sysexit 指令并不成对，sysenter 指令并不会把 SYSEXIT 所需的返回地址压栈，sysexit 返回的地址并不一定是 sysenter 指令的下一个指令地址。调用 sysenter&#x2F;sysexit 指令地址的跳转是通过设置一组特殊寄存器实现的。</span><br></pre></td></tr></table></figure>

<p>vdos的局限（syscall）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而&quot;快速系统调用指令&quot;比起中断方式的系统调用方式，还存在一定局限，例如无法在一个系统调用处理过程中再通过&quot;快速系统调用指令&quot;调用别的系统调用。因此，并不一定每个系统调用都需要通过&quot;快速系统调用指令&quot;来实现。比如，对于复杂的系统调用例如 fork，两种系统调用方式的时间差和系统调用本身运行消耗的时间来比，可以忽略不计，此处采取&quot;快速系统调用指令&quot;方式没有什么必要。而真正应该使用&quot;快速系统调用指令&quot;方式的，是那些本身运行时间很短，对时间精确性要求高的系统调用，例如 getuid、gettimeofday 等等。</span><br></pre></td></tr></table></figure>

<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>int 是最老的方式，目前用amd64的 syscall 方式， 而vdso是基于syscall实现的快速调用。<br>只有在调用clock_gettime、gettimeofday、getcpu、time这些系统调用时，才会使用vdso，其他系统调用是通过syscall实现的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/09/system-calls-method/" data-id="clsbmbv4t004jbwop68u4eree" data-title="system calls method" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">系统调用</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-huawei-unlock-bootloader" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/05/huawei-unlock-bootloader/" class="article-date">
  <time class="dt-published" datetime="2020-11-05T08:01:42.000Z" itemprop="datePublished">2020-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/05/huawei-unlock-bootloader/">huawei unlock bootloader</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>解锁华为平板M3的BL锁，以及获取root权限</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我有一个华为平板M3，WIFI版, 型号BTV-W09，系统是emui5， 买来没什么用，最大的功能就是看视频。 偶尔发现一个app，LinuxDeploy, 可以在安卓上安装完整的Linux系统，而不是内置的阉割版， 前提是获得root权限。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>全部步骤分4个：   </p>
<ol>
<li>解BL</li>
<li>刷入recovery 也就是RTWP</li>
<li>将root压缩包复制到平板，在RTWP下安装</li>
<li>安装supersu 的apk</li>
<li>可选刷入xposed框架，并安装xposed manager，步骤参考3,4</li>
</ol>
<h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><p>因为华为官方停止申请解锁BL的服务， 所以需要上淘宝找人帮你搞定。 解锁BL之后， 在关机状态按住电源和音量减，进入fastboot模式时，有红字提示unlocked</p>
<h2 id="刷入rec"><a href="#刷入rec" class="headerlink" title="刷入rec"></a>刷入rec</h2><p>找到与设备型号对应的rec非常重要，因为型号不对会刷不进去，我尝试了很多个版本，最终在华为论坛找到了。<br>有了rec后， 让手机处于fastboot状态， 连接手机到电脑，使用 <code>fastboot flash recovery rec</code> 来刷入 ，提书刷入成功之后，可能自动重启，如果没有重启，长按电源键强制关机。<br>关机状态下， 按住电源键和音量+，进入recovery ， 能看到RTWP的界面说明输入成功，如果没有看到RTWP,而是进入华为官方的eRecovery 表示失败，又可能是被华为覆盖了。<br>一旦能进入RTWP, 那么RTWP会自动安装，以后就不用担心被覆盖的问题。</p>
<h2 id="刷入root工具"><a href="#刷入root工具" class="headerlink" title="刷入root工具"></a>刷入root工具</h2><p>将root.zip 拷贝到平板的储存卡目录，进入RTWP，点INSTALL,  然后选择root.zip 就会开始安装了， 安装后再安装supersu 的应用</p>
<p>这样就root成功了， 所以步骤很简单，找到对应机型的rec 很关键。 </p>
<h2 id="刷入xposed"><a href="#刷入xposed" class="headerlink" title="刷入xposed"></a>刷入xposed</h2><p>xposed 很强大，但是xposed只是个框架，需要安装包来实现对app的hack。但是我安装完，没发现什么很强大包，感觉也没什么用。 </p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>平板一直都在吃灰，最近发现访问网站都报证书错误，可能是系统旧了(后面发现是电池馈电太久，时间不同步)，所以决定升级系统。这次完整贴出命令，因为发现我之前写的难以参考。在XDA网站发现有新的lineage17适合btv-w09,于是按照帖子里面的方法做：</p>
<ol>
<li>下载TWRP 3.3.1-1，lineage 17 系统压缩包， boot 镜像，我的是wifi-only版本。</li>
<li>在平板关闭状态下，按住电源+音量减，振动的时候释放电源键，然后就进入fastboot状态，显示<code>phone unlock</code></li>
<li>刷入twrp <code>fastboot flash recovery twrp-xxx.img</code></li>
<li>刷入boot <code>fastboot flash boot boot-xxx.img</code></li>
<li>进入twrp，这里有点迷惑，网上说（包括我之前说的）按住电源+音量加总是无法进入twrp而是进入了华为的eRecovery,使用<code>adb boot-recovery</code>则进入了正常系统。最后发现在开发者模式下开启<code>高级重启</code>功能，重启的时候选择重启到<code>recovery</code>则能正常进入Twrp界面。可能是平板接着USB线。</li>
<li>帖子上说了，升级lineage需要Wipe，彻底初始化但保留系统，执行后连sdcard目录也会格式化，剩几个标准目录。</li>
<li>用adb push 将系统安装压缩包发送到平板的存储空间，<code>adb push Lineage-xxx.zip /sdcard</code>，然后在TWRP中选择 Install，选择这个zip 进行安装。 不过发现这个zip文件校验失败，不管他了。</li>
</ol>
<p>然后就重启进入新版本的Lineage 17(android 10)，可惜的是没有相机功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/05/huawei-unlock-bootloader/" data-id="clsbmbv3p002obwop0z69as5t" data-title="huawei unlock bootloader" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hawei/" rel="tag">hawei</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/" rel="tag">刷机教程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Install-KVM-on-Debian-of-aarch64-architecture" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/30/Install-KVM-on-Debian-of-aarch64-architecture/" class="article-date">
  <time class="dt-published" datetime="2020-10-30T08:29:37.000Z" itemprop="datePublished">2020-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/30/Install-KVM-on-Debian-of-aarch64-architecture/">Install KVM on Debian of aarch64 architecture </a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司有台arm64位的设备，安装的银河麒麟系统，经验证就是debian 9。<br>现在需要运行更多arm64虚拟机。</p>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="配置免密sudoer"><a href="#配置免密sudoer" class="headerlink" title="配置免密sudoer"></a>配置免密sudoer</h2><p>这里记一个坑， 第一次配置时拼写错误，导致sudo 命令执行失败。需要重置密码，所以很麻烦。<br>然后推荐使用 <code>sudo visudo</code> 命令来修改sudoer配置文件，这个命令在编辑结束后校验配置文件，避免出现编辑错误导致无法使用sudo的情况。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kylin@Kylin:~$ cat &#x2F;etc&#x2F;sudoers.d&#x2F;kylin </span><br><span class="line">kylin	ALL&#x3D;(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<h2 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h2><p>第一个是本地iso, 下面的是中科大的镜像源。 每个都设置了trust免校验gpg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deb [trusted&#x3D;yes] file:&#x2F;&#x2F;&#x2F;mnt&#x2F;iso&#x2F; juniper main multiverse restricted universe</span><br><span class="line">deb [trusted&#x3D;yes] http:&#x2F;&#x2F;ftp.cn.debian.org&#x2F;debian&#x2F; stretch main contrib non-free</span><br><span class="line">deb [trusted&#x3D;yes] http:&#x2F;&#x2F;ftp.cn.debian.org&#x2F;debian&#x2F; stretch-updates main contrib non-free</span><br><span class="line">deb [trusted&#x3D;yes] http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian-security&#x2F; stretch&#x2F;updates main contrib non-free</span><br><span class="line">deb [trusted&#x3D;yes] http:&#x2F;&#x2F;ftp.cn.debian.org&#x2F;debian&#x2F; stretch-backports main contrib non-free</span><br></pre></td></tr></table></figure>

<h2 id="安装虚拟工具"><a href="#安装虚拟工具" class="headerlink" title="安装虚拟工具"></a>安装虚拟工具</h2><p>安装 qemu, libvirt, virt-manager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install  qemu  libvirt virt-manager</span><br></pre></td></tr></table></figure>

<h2 id="libvirt-没有网络"><a href="#libvirt-没有网络" class="headerlink" title="libvirt 没有网络"></a>libvirt 没有网络</h2><p>执行<code>virsh net-list -all</code> 发现default 网络处于未激活状态， 于是执行 <code>systemctl status libvirtd</code> 发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10月 30 15:46:27 Kylin libvirtd[16741]: 2020-10-30 07:46:27.262+0000: 16764: error : virFileReadAll:1420 : 打开文件 &#39;&#x2F;sys&#x2F;class&#x2F;net&#x2F;virbr0-nic&#x2F;operstate&#39; 失败: 没有那个文件或目录</span><br><span class="line">10月 30 15:46:27 Kylin libvirtd[16741]: 2020-10-30 07:46:27.262+0000: 16764: error : virNetDevGetLinkInfo:2530 : unable to read: &#x2F;sys&#x2F;class&#x2F;net&#x2F;virbr0-nic&#x2F;operstate: 没有那个文件或目录</span><br><span class="line">10月 30 15:46:54 Kylin libvirtd[16741]: 2020-10-30 07:46:54.710+0000: 16745: error : virFirewallApply:916 : 内部错误：Failed to initialize a valid firewall backend</span><br></pre></td></tr></table></figure>
<p>需要安装以下组件，然后重启libvirtd，这是因为libvirt的网络依赖这几个组件来创建nat 网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ebtables iptables dnsmasq</span><br><span class="line">systemctl restart libvirtd</span><br></pre></td></tr></table></figure>

<h2 id="virt-manager-提示aarch64-安装-uefi-错误"><a href="#virt-manager-提示aarch64-安装-uefi-错误" class="headerlink" title="virt-manager 提示aarch64 安装 uefi 错误"></a>virt-manager 提示aarch64 安装 uefi 错误</h2><p>直接安装 qemu-efi</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install qemu-efi</span><br></pre></td></tr></table></figure>

<h2 id="virt-manager-允许非root用户访问"><a href="#virt-manager-允许非root用户访问" class="headerlink" title="virt-manager 允许非root用户访问"></a>virt-manager 允许非root用户访问</h2><p>因为当以普通用户运行 virt-manager 时，qemu的连接指向非qemu:///system， 这时看到的虚拟机和root看到的不一样，所以必须使用sudo运行。<br>通过修改配置来启用普通用户也访问<code>qemu:///system</code>， 将uri_defualt 的注释去掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;libvirt&#x2F;libvirt.conf </span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># These can be used in cases when no URI is supplied by the application</span><br><span class="line"># (@uri_default also prevents probing of the hypervisor driver).</span><br><span class="line">#</span><br><span class="line">uri_default &#x3D; &quot;qemu:&#x2F;&#x2F;&#x2F;system&quot;</span><br></pre></td></tr></table></figure>


<h1 id="这样就可以使用virt-manager来创建虚拟机了，跟x86的使用一样。"><a href="#这样就可以使用virt-manager来创建虚拟机了，跟x86的使用一样。" class="headerlink" title="这样就可以使用virt-manager来创建虚拟机了，跟x86的使用一样。"></a>这样就可以使用virt-manager来创建虚拟机了，跟x86的使用一样。</h1><p>顺便记一下vnc的配置， 因为机器在机房里， 通过tigervnc来使用桌面。<br>另外提示一下，virt-manager 配置好后，可以直接连接远程的virt-manager,非常方便。</p>
<p>使用tigervnc 连接需要在远程主机安装 tigervnc-server 和 tigervnc-password。<br>使用普通用户执行 <code>tigervnc-password</code> 设置访问密码，然后直接执行<code>tigervnc-server</code>。</p>
<p>这时候vnc只接受本地连接， 如果远程访问，要使用ssh 本地转发来实现。 这也是vnc推荐的方式。</p>
<p>现在本地允许本地转发命令， 监听本地端口 9302, 转发到远程的 9300</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 9302:localhost:9300   -N -f  ssh-kylin</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>vncviewer  127.0.0.1:9302</code> ，输入密码就能打开远程桌面了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/10/30/Install-KVM-on-Debian-of-aarch64-architecture/" data-id="clsbmbv2v0018bwopfgywaa4r" data-title="Install KVM on Debian of aarch64 architecture " class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aarch64/" rel="tag">aarch64</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lvm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/22/lvm/" class="article-date">
  <time class="dt-published" datetime="2020-10-22T08:01:53.000Z" itemprop="datePublished">2020-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/22/lvm/">lvm 的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LVM-功能介绍"><a href="#LVM-功能介绍" class="headerlink" title="LVM 功能介绍"></a>LVM 功能介绍</h1><p>LVM 是在硬件和系统之间多加了一层，可以很方便地修改分区和扩容。 从效率上看肯定有所损失的，但是对于企业而言，灵活性也很重要<br>LVM具有在线扩容和快照的重要功能</p>
<h2 id="在线扩容"><a href="#在线扩容" class="headerlink" title="在线扩容"></a>在线扩容</h2><p>当磁盘容量不够或者需要替换磁盘时，就需要扩容, 如果是替换磁盘就再需要换出旧硬盘</p>
<h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><p>使用lvm中的pvmove 命令假如原来是使用pv 为/dev/sda1, 新的硬盘为/dev/sdb1  </p>
<ol>
<li>新建pv: #pvcreate /dev/sdb1 </li>
<li>扩容vg：#vgextend vg1 /dev/sdb1 </li>
<li>如果要调整分区大小，使用lvresize -r -S 新大小。 不带-r的话需要重新mount才能生效， -S 是表示最终大小，-s +/- 是调整大小</li>
</ol>
<h3 id="换出步骤"><a href="#换出步骤" class="headerlink" title="换出步骤"></a>换出步骤</h3><p>vgreduce 是将pv踢出vg, pvremove是删除pv标记</p>
<ol>
<li>把sda1 上数据迁移到sdb1上： #pvmove  /dev/sda1  /dev/sdb1 </li>
<li>vgreduce 从vg1踢出sda1盘 #vgreduce vg1 /dev/sda1  </li>
<li>pvremove 删除磁盘分区的pv 标记 #pvremove /dev/sda1 </li>
</ol>
<h3 id="磁盘换出是否需要停业务"><a href="#磁盘换出是否需要停业务" class="headerlink" title="磁盘换出是否需要停业务"></a>磁盘换出是否需要停业务</h3><p>LVM的在线扩容是不需要停止业务的，但是应该在业务闲的时候做。LVM在做pvmove的时候，会冻结旧分区，新的操作就需要做备份。<br>pvmove有时候很慢，但是不能中断，否则出现很多遗留的分区。 </p>
<p>与pvmove类似的功能的还有磁盘镜像， 磁盘镜像的好处很明显，即使复制失败了，原数据依然存在。</p>
<p>但两个技术都要求能够“原子化”，所以不得不对业务有所影响，而且影响的是磁盘IO， 无法通过降低业务的NICE值来减弱这种影响</p>
<h2 id="LVM-快照功能"><a href="#LVM-快照功能" class="headerlink" title="LVM 快照功能"></a>LVM 快照功能</h2><p>当系统是安装在LVM文件系统之上，那么当需要进行高危操作的时候，可以先对分区进行快照备份，避免操作失败又无法恢复。<br>公司有一台centos7的自用系统， 需要升级到Centos8 以支持 Docker buildx。<br>虽然因操作到无法运行yum,dnf 时宣布失败，但好在有snapshot备份， 恢复后完好如初，太好用。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>挂载如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ lsblk </span><br><span class="line">NAME                  MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT</span><br><span class="line">sda                     8:0    0   477G  0 disk  </span><br><span class="line">├─sda1                  8:1    0   200M  0 part  /boot/efi</span><br><span class="line">├─sda2                  8:2    0     1G  0 part  /boot</span><br><span class="line">└─sda3                  8:3    0 475.8G  0 part  </span><br><span class="line">  ├─centos-root       253:2    0    50G  0 lvm   /</span><br><span class="line">  ├─centos-swap       253:4    0  15.7G  0 lvm   [SWAP]</span><br><span class="line">  ├─centos-docker     253:18   0   150G  0 lvm   /var/lib/docker</span><br></pre></td></tr></table></figure>

<p>根分区为50G, 而卷组还剩余160G,完全足够生成一个镜像，50G并未完全使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vgs</span><br><span class="line">  VG     #PV #LV #SN Attr   VSize   VFree   </span><br><span class="line">  centos   1   4   0 wz--n- 475.74g  160.05g</span><br><span class="line">  data     1  13   0 wz--n-  &lt;7.28t &lt;721.91g</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>先对根分区进行快照，注意是<code>根分区</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># lvcreate -s -n &lt;snapshot_name&gt; -L &lt;size&gt; &lt;logical_volume&gt;</span><br><span class="line"></span><br><span class="line">$ lvcreate -s -n backup -L 50G  &#x2F;dev&#x2F;centos&#x2F;root</span><br></pre></td></tr></table></figure>
<p>这里指定了快照的大小为50G, 理论上是要比源分区大， 这里也可以直接设置100G, 系统会自动调整大小到合适。</p>
</li>
<li><p>进行一顿操作后， 进行恢复, 提示根分区正在使用， 重启后生效。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lvconvert --mergesnapshot &#x2F;dev&#x2F;centos&#x2F;backup </span><br><span class="line">  Delaying merge since origin is open.</span><br><span class="line">  Merging of snapshot centos&#x2F;backup will occur on next activation of centos&#x2F;root.</span><br></pre></td></tr></table></figure>

<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>如果需要对快照进行备份到其他位置， 可以直接将快照分区挂载，然后通过tarball 来压缩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvzf backup.tar.gz &#x2F;mnt&#x2F;lv_snapshot</span><br></pre></td></tr></table></figure>

<p>还可以直接通过rsync 将挂载的snapshort 传输到其他服务器上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -aPh &#x2F;mnt&#x2F;lv_snapshot  &lt;remote_user&gt;@&lt;destination_server&gt;:&lt;remote_destination&gt;</span><br></pre></td></tr></table></figure>

<h3 id="快照回滚"><a href="#快照回滚" class="headerlink" title="快照回滚"></a>快照回滚</h3><p>lvm的snapshort 也是写时复制的（copy on write），所以创建快照操作非常快，<br>当分区进行删除和修改操作的时候， lvm文件系统会拷贝文件到其他地方保存。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>lvm快照不等于备份， 仅有快照是不能恢复的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/10/22/lvm/" data-id="clsbmbv3z0031bwop0h3p6f0n" data-title="lvm 的使用" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/filesystem/" rel="tag">filesystem</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lvm/" rel="tag">lvm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux-Interrupts" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/19/Linux-Interrupts/" class="article-date">
  <time class="dt-published" datetime="2020-10-19T08:15:16.000Z" itemprop="datePublished">2020-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/19/Linux-Interrupts/">Linux Interrupts</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux-中断请求"><a href="#Linux-中断请求" class="headerlink" title="Linux 中断请求"></a>Linux 中断请求</h1><p>中断请求的英文是IRQ（Interrupt Request）,是用来驱动CPU正常工作的重要机制。 中断根据源头分类成：<br>由外设发出的硬件中断，软件发出的软中断，以及异常组成。</p>
<p>以前，每个外设都连接一根线到PIC(programmable Interrupt circuit)芯片，有PIC芯片来发生数据到CPU,并将CPU的INTR引脚置位。<br>现在，CPU集成了PIC成为APIC(Advanced PIC)。</p>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p>中断分为3类型</p>
<h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>鼠标和键盘，还有IO设备都会发出硬件中断，例如网卡的数据到了，就会出发中断请求（IRQ），<br>这个请求会触发CPU去执行ISR, 而这个ISR需要在系统启动的时候注册的。一个Vector表。</p>
<h2 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h2><p>当播放电影的时候，声音和画面的同步非常重要，这是由系统的定时器<a href="https://elinux.org/Kernel_Timer_Systems" target="_blank" rel="noopener">jiffies</a>来不停地调度声音播放器来准确播放对应的声音。<br>软中断在实时操作系统的作用也非常重要。</p>
<h3 id="异常中断"><a href="#异常中断" class="headerlink" title="异常中断"></a>异常中断</h3><p>异常中断又分为3类： 缺页异常(Faults)，陷入异常(Traps)，异常退出(Aborts)</p>
<p>例如当程序的内存被swap到硬盘了或者一段动态链接库还没有载入到内存里来，在程序走到这个位置之前，<br>程序就会提前发出缺页异常，当系统检查了权限和地址有效后（地址有效表示在逻辑地址范围内），<br>CPU开始为程序执行加载需要的数据，并清除这个异常。 所以这个异常是可以修正的，这个请求必须提前发出。</p>
<p>当GDB调试的时，设置断点会插入一条特殊的指令到程序里，当执行到断点位置就会出发Traps请求，软件的主导权由CPU交给GDB。</p>
<p>当程序触发一个异常例如0/0时，会出发退出异常，由cpu来清理堆栈。</p>
<h2 id="请求的可阻塞性"><a href="#请求的可阻塞性" class="headerlink" title="请求的可阻塞性"></a>请求的可阻塞性</h2><p>对于硬件中断请求，CPU的决策是立即执行，对于软中断和异常，CPU采用尽量延后的策略。</p>
<h2 id="查看系统的中断"><a href="#查看系统的中断" class="headerlink" title="查看系统的中断"></a>查看系统的中断</h2><p>在中断执行 <code>watch -n1 &quot;cat /proc/interrupts&quot;</code>可以定时更新中断的次数</p>
<p>列的含义从左至右以此为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRQ vector, interrupt count per CPU (0 .. n), the hardware source, the hardware source&#39;s channel information, and the name of the device that caused the IRQ.</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/10/19/Linux-Interrupts/" data-id="clsbmbv2w001abwop74dxa5dy" data-title="Linux Interrupts" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/" rel="tag">内核原理</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">51单片机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aarch64/" rel="tag">aarch64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/admin/" rel="tag">admin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algoritm/" rel="tag">algoritm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bash/" rel="tag">bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/basics/" rel="tag">basics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-c/" rel="tag">c/c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmake/" rel="tag">cmake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dns/" rel="tag">dns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/email-client/" rel="tag">email_client</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/exam/" rel="tag">exam</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/exception-safe/" rel="tag">exception-safe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ffmpeg/" rel="tag">ffmpeg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/filesystem/" rel="tag">filesystem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gdb/" rel="tag">gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grpc/" rel="tag">grpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grub/" rel="tag">grub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hawei/" rel="tag">hawei</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/heapsort/" rel="tag">heapsort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linkage/" rel="tag">linkage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%9F%BA%E7%A1%80/" rel="tag">linux基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock/" rel="tag">lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lvm/" rel="tag">lvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maintance/" rel="tag">maintance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/malloc/" rel="tag">malloc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mdns/" rel="tag">mdns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory/" rel="tag">memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mutex/" rel="tag">mutex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mutt/" rel="tag">mutt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/namespace/" rel="tag">namespace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/os-maintain/" rel="tag">os-maintain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/printer/" rel="tag">printer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/program/" rel="tag">program</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rancher-k8s/" rel="tag">rancher,k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rhce/" rel="tag">rhce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rtp/" rel="tag">rtp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/safe/" rel="tag">safe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scope/" rel="tag">scope</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/seralize/" rel="tag">seralize</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shared-ptr/" rel="tag">shared_ptr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socketopt/" rel="tag">socketopt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storageduration/" rel="tag">storageduration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sysemd/" rel="tag">sysemd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/template-programing/" rel="tag">template programing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/terminal/" rel="tag">terminal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/udp/" rel="tag">udp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unique-ptr/" rel="tag">unique_ptr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unit-test/" rel="tag">unit test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/urxvt/" rel="tag">urxvt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webcrawler/" rel="tag">webcrawler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webserver/" rel="tag">webserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weechat/" rel="tag">weechat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wordpress/" rel="tag">wordpress</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/" rel="tag">内核原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/" rel="tag">刷机教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" rel="tag">包管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E6%89%BE/" rel="tag">查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">系统调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E4%BC%98/" rel="tag">调优</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" rel="tag">音视频</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 10px;">51单片机</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/aarch64/" style="font-size: 10px;">aarch64</a> <a href="/tags/admin/" style="font-size: 10px;">admin</a> <a href="/tags/algorithm/" style="font-size: 16px;">algorithm</a> <a href="/tags/algoritm/" style="font-size: 10px;">algoritm</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/basics/" style="font-size: 10px;">basics</a> <a href="/tags/c/" style="font-size: 12px;">c++</a> <a href="/tags/c-c/" style="font-size: 20px;">c/c++</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/dns/" style="font-size: 10px;">dns</a> <a href="/tags/docker/" style="font-size: 18px;">docker</a> <a href="/tags/email-client/" style="font-size: 10px;">email_client</a> <a href="/tags/exam/" style="font-size: 10px;">exam</a> <a href="/tags/exception-safe/" style="font-size: 10px;">exception-safe</a> <a href="/tags/ffmpeg/" style="font-size: 10px;">ffmpeg</a> <a href="/tags/filesystem/" style="font-size: 14px;">filesystem</a> <a href="/tags/flask/" style="font-size: 10px;">flask</a> <a href="/tags/gdb/" style="font-size: 10px;">gdb</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/grpc/" style="font-size: 10px;">grpc</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/hawei/" style="font-size: 10px;">hawei</a> <a href="/tags/heapsort/" style="font-size: 10px;">heapsort</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linkage/" style="font-size: 10px;">linkage</a> <a href="/tags/linux/" style="font-size: 14px;">linux</a> <a href="/tags/linux%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">linux基础</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/lvm/" style="font-size: 10px;">lvm</a> <a href="/tags/maintance/" style="font-size: 10px;">maintance</a> <a href="/tags/malloc/" style="font-size: 10px;">malloc</a> <a href="/tags/mdns/" style="font-size: 10px;">mdns</a> <a href="/tags/memory/" style="font-size: 12px;">memory</a> <a href="/tags/mutex/" style="font-size: 10px;">mutex</a> <a href="/tags/mutt/" style="font-size: 10px;">mutt</a> <a href="/tags/namespace/" style="font-size: 10px;">namespace</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/os-maintain/" style="font-size: 10px;">os-maintain</a> <a href="/tags/printer/" style="font-size: 10px;">printer</a> <a href="/tags/program/" style="font-size: 10px;">program</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/rancher-k8s/" style="font-size: 10px;">rancher,k8s</a> <a href="/tags/rhce/" style="font-size: 10px;">rhce</a> <a href="/tags/rtp/" style="font-size: 10px;">rtp</a> <a href="/tags/safe/" style="font-size: 12px;">safe</a> <a href="/tags/scope/" style="font-size: 10px;">scope</a> <a href="/tags/seralize/" style="font-size: 10px;">seralize</a> <a href="/tags/shared-ptr/" style="font-size: 10px;">shared_ptr</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/socketopt/" style="font-size: 10px;">socketopt</a> <a href="/tags/sql/" style="font-size: 12px;">sql</a> <a href="/tags/storageduration/" style="font-size: 10px;">storageduration</a> <a href="/tags/sysemd/" style="font-size: 10px;">sysemd</a> <a href="/tags/template-programing/" style="font-size: 10px;">template programing</a> <a href="/tags/terminal/" style="font-size: 10px;">terminal</a> <a href="/tags/tool/" style="font-size: 18px;">tool</a> <a href="/tags/udp/" style="font-size: 10px;">udp</a> <a href="/tags/unique-ptr/" style="font-size: 10px;">unique_ptr</a> <a href="/tags/unit-test/" style="font-size: 10px;">unit test</a> <a href="/tags/urxvt/" style="font-size: 10px;">urxvt</a> <a href="/tags/webcrawler/" style="font-size: 10px;">webcrawler</a> <a href="/tags/webserver/" style="font-size: 10px;">webserver</a> <a href="/tags/weechat/" style="font-size: 10px;">weechat</a> <a href="/tags/wordpress/" style="font-size: 10px;">wordpress</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/" style="font-size: 10px;">内核原理</a> <a href="/tags/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/" style="font-size: 10px;">刷机教程</a> <a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 10px;">包管理</a> <a href="/tags/%E6%9F%A5%E6%89%BE/" style="font-size: 10px;">查找</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" style="font-size: 10px;">系统调用</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 10px;">编译</a> <a href="/tags/%E8%B0%83%E4%BC%98/" style="font-size: 10px;">调优</a> <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" style="font-size: 10px;">音视频</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/07/streaming-h264-with-rtp/">streaming h264 with rtp</a>
          </li>
        
          <li>
            <a href="/2023/09/08/wifi-tool/">随身wifi工具</a>
          </li>
        
          <li>
            <a href="/2023/07/21/docker-network/">docker network</a>
          </li>
        
          <li>
            <a href="/2023/07/18/mail-setup/">mail setup</a>
          </li>
        
          <li>
            <a href="/2023/07/08/install-wordpress/">install wordpress</a>
          </li>
        
          <li>
            <a href="/2022/12/29/amrnb-and-amrwb/">amrnb和amrwb的编解码</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 greek_soon@hotmail.com<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>