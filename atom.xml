<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>又是元气满满的一天</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://energygreek.github.io/atom.xml" rel="self"/>
  
  <link href="https://energygreek.github.io/"/>
  <updated>2024-02-07T09:59:29.791Z</updated>
  <id>https://energygreek.github.io/</id>
  
  <author>
    <name>greek_soon@hotmail.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>streaming h264 with rtp</title>
    <link href="https://energygreek.github.io/2024/02/07/streaming-h264-with-rtp/"/>
    <id>https://energygreek.github.io/2024/02/07/streaming-h264-with-rtp/</id>
    <published>2024-02-07T03:34:38.000Z</published>
    <updated>2024-02-07T09:59:29.791Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录了使用ffmpeg来发送h264的rtp流，主要问题是处理pps和sps的发送，看了非常多的文档和例子包括gptchat，直到用gdb跟ffmpeg才找到解决办法。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司的有个发送视频彩铃的业务，需要向终端发送h264。开始想法是创建ffmpeg进程来发送，不过发现进程太好资源并发上不去。后来用写代码来多线程发送。</p><h3 id="sdp协商转码问题"><a href="#sdp协商转码问题" class="headerlink" title="sdp协商转码问题"></a>sdp协商转码问题</h3><p>sdp协商结果会有不同的分辨率、等级、质量之类的参数(pps/sps)，为了避免转码，提前制作了不同参数的视频。不过后来发现只要正确发送pps/sps，终端都能正确解码，不是必须按sdp里的视频参数。</p><h3 id="用ffmpeg发送"><a href="#用ffmpeg发送" class="headerlink" title="用ffmpeg发送"></a>用ffmpeg发送</h3><p>开始直接使用命令ffmpeg发送，发现终端不能解码。对比正常的rtp流发现缺少了pps/sps。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.mp4 -an -c:v copy -f rtp rtp:&#x2F;&#x2F;ip:port</span><br></pre></td></tr></table></figure><p>一番搜索发现ffmpeg将pps/sps等参数写到sdp中(out-of-band)，还用base64编码了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;fmtp:96 packetization-mode&#x3D;1; sprop-parameter-sets&#x3D;Z2QAKKzRAHgCJ+XAWoCAgKAAAAMAIAAAB4HjBiJA,aOvvLA&#x3D;&#x3D;; profile-level-id&#x3D;640028</span><br></pre></td></tr></table></figure><p>ffplay等播放软件会解析sdp，载入pps/sps，所以正确解码，但是sip场景下只能通过rtp来发送sps/pps(in-band)。 后来发现用ffmpeg的’bit stream filter’能解决问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.mp4 -an -c:v copy -bsf h264_mp4toannexb -f rtp rtp:&#x2F;&#x2F;ip:port</span><br></pre></td></tr></table></figure><p>即使不转码，使用ffmpeg进程发送视频，在两核的系统中大概只能发送十几路。</p><h3 id="代码实现发送"><a href="#代码实现发送" class="headerlink" title="代码实现发送"></a>代码实现发送</h3><p>基于ffmpeg的示例代码’doc/example/remux.c’, 将原来写文件改为rtp即可。因为还没有用到’h264_mp4toannexb’，还不会发送pps和sps。</p><h4 id="关键问题就是如何使用这个bsf"><a href="#关键问题就是如何使用这个bsf" class="headerlink" title="关键问题就是如何使用这个bsf"></a>关键问题就是如何使用这个bsf</h4><p>网上看到的例子包括用gptchat生成的例子，都是类似下面的步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 搜索bsf</span><br><span class="line">av_bsf_get_by_name(&quot;h264_mp4toannexb&quot;)</span><br><span class="line"># 创建bsf的上下文</span><br><span class="line">av_bsf_alloc(bsf, &amp;bsf_ctx)</span><br><span class="line"># 从输入的format上下文中复制编码参数</span><br><span class="line">avcodec_parameters_copy(bsf_ctx-&gt;par_in, input_ctx-&gt;streams[video_stream_idx]-&gt;codecpar)</span><br><span class="line"># 初始化bsf上下文</span><br><span class="line">av_bsf_init(bsf_ctx)</span><br><span class="line"># 读入packet</span><br><span class="line">av_read_frame(input_ctx, &amp;pkt)</span><br><span class="line"># 送到bsf中处理</span><br><span class="line">av_bsf_send_packet(bsf_ctx, pkt)</span><br><span class="line"># 取出处理后的pkt</span><br><span class="line">av_bsf_receive_packet(bsf_ctx, pkt)</span><br><span class="line"># 发送rtp</span><br></pre></td></tr></table></figure><p>抓包发现还是没有发送PPS/SPS, 而且第一个NALU是SEI，并且是坏的(Malformed)。调试发现bsf确实成功将SEI从AVCC转换成了AnnexB形式，也在SEI后追加了PPS和SPS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x&#x2F;150bx pkt-&gt;data</span><br><span class="line">0x5555556da310: 0x00    0x00    0x00    0x01    0x06    0x05    0x2e    0xdc</span><br><span class="line">0x5555556da318: 0x45    0xe9    0xbd    0xe6    0xd9    0x48    0xb7    0x96</span><br><span class="line">0x5555556da320: 0x2c    0xd8    0x20    0xd9    0x23    0xee    0xef    0x78</span><br><span class="line">0x5555556da328: 0x32    0x36    0x34    0x20    0x2d    0x20    0x63    0x6f</span><br><span class="line">0x5555556da330: 0x72    0x65    0x20    0x31    0x35    0x35    0x20    0x72</span><br><span class="line">0x5555556da338: 0x32    0x39    0x30    0x31    0x20    0x37    0x64    0x30</span><br><span class="line">0x5555556da340: 0x66    0x66    0x32    0x32    0x00    0x80    0x00    0x00</span><br><span class="line">0x5555556da348: 0x00    0x01    0x67    0x64    0x00    0x28    0xac    0xd1</span><br><span class="line">0x5555556da350: 0x00    0x78    0x02    0x27    0xe5    0xc0    0x5a    0x80</span><br><span class="line">0x5555556da358: 0x80    0x80    0xa0    0x00    0x00    0x03    0x00    0x20</span><br><span class="line">0x5555556da360: 0x00    0x00    0x07    0x81    0xe3    0x06    0x22    0x40</span><br><span class="line">0x5555556da368: 0x00    0x00    0x00    0x01    0x68    0xeb    0xef    0x2c</span><br><span class="line">0x5555556da370: 0x00    0x00    0x01    0x65    0x88    0x84    0x02    0xff</span><br><span class="line">0x5555556da378: 0x91    0x3c    0x4a    0x51    0x5b    0xfd    0x02    0x3f</span><br><span class="line">0x5555556da380: 0xc1    0x67    0x8d    0xc0    0x94    0x98    0xee    0x7d</span><br><span class="line">0x5555556da388: 0x43    0x23    0xc0    0x4f    0xf7    0x56    0x37    0xfc</span><br><span class="line">0x5555556da390: 0xf1    0xf3    0xd3    0x83    0x03    0xa9    0x6d    0xd2</span><br><span class="line">0x5555556da398: 0x07    0xcf    0x19    0xa2    0x1e    0x29    0x64    0xfe</span><br><span class="line">0x5555556da3a0: 0x1f    0x8e    0xd6    0x71    0x5f    0x33</span><br></pre></td></tr></table></figure><p><code>0x00 0x00 0x00 0x01</code>是annexb格式的起始码，第一个NALU是0x06(SEI)，第二个NALU是0x07(SPS)，第三个是0x08(PPS)。问题出在rtp打包的<code>ff_rtp_send_h264_hevc</code>。这里判断出<code>s-&gt;nal_length_size</code>不是0而是4, 所以还是以AVCC格式的首四个字节代表长度来解析pkt，而这是pkt是annexB格式了，前四个字节就是0x00, 0x00, 0x00, 0x01。所以打包错误。 问题怎么使rtp按annexB来打包，为什么<code>nal_length_size</code>是4不是0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void ff_rtp_send_h264_hevc(AVFormatContext *s1, const uint8_t *buf1, int size)</span><br><span class="line">&#123;</span><br><span class="line">    const uint8_t *r, *end &#x3D; buf1 + size;</span><br><span class="line">    RTPMuxContext *s &#x3D; s1-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">    s-&gt;timestamp &#x3D; s-&gt;cur_timestamp;</span><br><span class="line">    s-&gt;buf_ptr   &#x3D; s-&gt;buf;</span><br><span class="line">    if (s-&gt;nal_length_size)</span><br><span class="line">        r &#x3D; ff_avc_mp4_find_startcode(buf1, end, s-&gt;nal_length_size) ? buf1 : end;</span><br><span class="line">    else</span><br><span class="line">        r &#x3D; ff_avc_find_startcode(buf1, end);</span><br></pre></td></tr></table></figure><p>找到初始化rtp的初始化函数<code>rtp_write_header</code>，发现设置<code>nal_length_size</code>的地方，原来判断extradata，如果第一个字节是1,则按avcc打包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case AV_CODEC_ID_H264:</span><br><span class="line">    &#x2F;* check for H.264 MP4 syntax *&#x2F;</span><br><span class="line">    if (st-&gt;codecpar-&gt;extradata_size &gt; 4 &amp;&amp; st-&gt;codecpar-&gt;extradata[0] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        s-&gt;nal_length_size &#x3D; (st-&gt;codecpar-&gt;extradata[4] &amp; 0x03) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>而当前的extradata是类似avcc的（又不同于AVCC, 因为多一个header)，第一个字节等于1，而通过调试ffmpeg_g到这里时，extradata是annexB格式，即首4个字节是0x00,0x00,0x00,0x01。关于extradata格式的问题，从开始我就发现刚初始化时，extradata就是0x01开头，那么问题ffmpeg_g的extradata什么时候变的，再次调试发现，bsf初始化跟上面的不同。在ffmpeg_g中bsf初始化在fftools/ffmpeg_mux.c文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># fftools&#x2F;ffmpeg_mux.c</span><br><span class="line">static int bsf_init(MuxStream *ms)</span><br><span class="line">&#123;</span><br><span class="line">    OutputStream *ost &#x3D; &amp;ms-&gt;ost;</span><br><span class="line">    AVBSFContext *ctx &#x3D; ms-&gt;bsf_ctx;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    if (!ctx)</span><br><span class="line">        return avcodec_parameters_copy(ost-&gt;st-&gt;codecpar, ost-&gt;par_in);</span><br><span class="line"></span><br><span class="line">    ret &#x3D; avcodec_parameters_copy(ctx-&gt;par_in, ost-&gt;par_in);</span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;time_base_in &#x3D; ost-&gt;st-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; av_bsf_init(ctx);</span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        av_log(ms, AV_LOG_ERROR, &quot;Error initializing bitstream filter: %s\n&quot;,</span><br><span class="line">               ctx-&gt;filter-&gt;name);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; avcodec_parameters_copy(ost-&gt;st-&gt;codecpar, ctx-&gt;par_out);</span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line">        return ret;</span><br><span class="line">    ost-&gt;st-&gt;time_base &#x3D; ctx-&gt;time_base_out;</span><br><span class="line"></span><br><span class="line">    ms-&gt;bsf_pkt &#x3D; av_packet_alloc();</span><br><span class="line">    if (!ms-&gt;bsf_pkt)</span><br><span class="line">        return AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现，ffmpeg的bsf初始化多一个步骤，将bsf的par_out拷贝到输出AVstream中。而这par_out中的extradata就是我们要的annexB格式！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; avcodec_parameters_copy(ost-&gt;st-&gt;codecpar, ctx-&gt;par_out);</span><br></pre></td></tr></table></figure><p>问题找到答案了，1是初始化rtp muxer前先初始化bsf，2是初始化bsf后将par_out拷贝回rtp muxer，再初始化rtp muxer。</p><h4 id="正确例子"><a href="#正确例子" class="headerlink" title="正确例子"></a>正确例子</h4><p>基于ffmpeg的doc/example/remux.c 删除了错误处理。只关心h264，所以输入输出都只处理index=0的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  const AVOutputFormat *ofmt &#x3D; NULL;</span><br><span class="line">  AVFormatContext *ifmt_ctx &#x3D; NULL, *ofmt_ctx &#x3D; NULL;</span><br><span class="line">  AVPacket *pkt &#x3D; NULL;</span><br><span class="line">  const char *in_filename, *out_filename;</span><br><span class="line">  int ret &#x3D; 0;</span><br><span class="line">  in_filename &#x3D; &quot;video.mp4&quot;;</span><br><span class="line">  out_filename &#x3D; &quot;rtp:&#x2F;&#x2F;127.0.0.1:10020&quot;;</span><br><span class="line">  pkt &#x3D; av_packet_alloc();</span><br><span class="line">  ret &#x3D; avformat_open_input(&amp;ifmt_ctx, in_filename, 0, 0);</span><br><span class="line">  ret &#x3D; avformat_find_stream_info(ifmt_ctx, 0);</span><br><span class="line">  av_dump_format(ifmt_ctx, 0, in_filename, 0);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建输出rtp上下文，不初始化</span><br><span class="line">  avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, &quot;rtp&quot;, out_filename);</span><br><span class="line">  &#x2F;&#x2F; 初始化bsf</span><br><span class="line">  const AVBitStreamFilter *bsf_stream_filter &#x3D;</span><br><span class="line">      av_bsf_get_by_name(&quot;h264_mp4toannexb&quot;);</span><br><span class="line">  AVBSFContext *bsf_ctx &#x3D; NULL;</span><br><span class="line">  ret &#x3D; av_bsf_alloc(bsf_stream_filter, &amp;bsf_ctx);</span><br><span class="line">  ret &#x3D;</span><br><span class="line">      avcodec_parameters_copy(bsf_ctx-&gt;par_in, ifmt_ctx-&gt;streams[0]-&gt;codecpar);</span><br><span class="line">  ret &#x3D; av_bsf_init(bsf_ctx);</span><br><span class="line"></span><br><span class="line">  ofmt &#x3D; ofmt_ctx-&gt;oformat;</span><br><span class="line">  AVStream *out_stream &#x3D; avformat_new_stream(ofmt_ctx, NULL);</span><br><span class="line">  &#x2F;&#x2F; 关键在这！！ 原来是从ifmt_ctx的stream中拷贝codecpar，改成从bsf中拷贝</span><br><span class="line">  &#x2F;&#x2F; ret &#x3D; avcodec_parameters_copy(out_stream-&gt;codecpar, in_codecpar);</span><br><span class="line">  ret &#x3D; avcodec_parameters_copy(out_stream-&gt;codecpar, bsf_ctx-&gt;par_out);</span><br><span class="line">  out_stream-&gt;codecpar-&gt;codec_tag &#x3D; 0;</span><br><span class="line">  av_dump_format(ofmt_ctx, 0, out_filename, 1);</span><br><span class="line">  if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">    ret &#x3D; avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 初始化bsf后再初始化rtp</span><br><span class="line">  ret &#x3D; avformat_write_header(ofmt_ctx, NULL);</span><br><span class="line"></span><br><span class="line">  while (1) &#123;</span><br><span class="line">    AVStream *in_stream, *out_stream;</span><br><span class="line">    ret &#x3D; av_read_frame(ifmt_ctx, pkt);</span><br><span class="line">    if (pkt-&gt;stream_index !&#x3D; 0) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    in_stream &#x3D; ifmt_ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">    out_stream &#x3D; ofmt_ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">    log_packet(ifmt_ctx, pkt, &quot;in&quot;);</span><br><span class="line"></span><br><span class="line">    av_bsf_send_packet(bsf_ctx, pkt);</span><br><span class="line">    av_bsf_receive_packet(bsf_ctx, pkt);</span><br><span class="line">    &#x2F;* copy packet *&#x2F;</span><br><span class="line">    av_packet_rescale_ts(pkt, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">    pkt-&gt;pos &#x3D; -1;</span><br><span class="line">    log_packet(ofmt_ctx, pkt, &quot;out&quot;);</span><br><span class="line">    ret &#x3D; av_interleaved_write_frame(ofmt_ctx, pkt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  av_write_trailer(ofmt_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="h264-mp4toannexb"><a href="#h264-mp4toannexb" class="headerlink" title="h264_mp4toannexb"></a>h264_mp4toannexb</h3><p>这个bsf将从mp4文件中读取的avcc格式的packet转换成annexb格式的packet。调试发现第一个读出来的包是SEI一个I帧，通过bsf处理后，会在SEI后面追加上PPS和SPS信息。而读取mp4文件时，sps/pps在extradata中。</p><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>这些知识反复看来看去，总也不能贯穿起来，直到问题解决才算明白。</p><h4 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h4><p>NALU是真正用来保存h264视频信息的，包括I帧，P/B帧，PPS，SEI，SPS等。NALU由两部分组成：头（1字节）和payload，头中包含nalu的类型。h264规范只定义了NALU本身单元，但没有定义怎么保存NALU单元，所以有了两种格式保存NALU，AVCC和AnnexB。</p><h5 id="NALU类型"><a href="#NALU类型" class="headerlink" title="NALU类型"></a>NALU类型</h5><p>NAL unit type的值和说明，类型后面跟payload。详细参见在Rec. ITU-T H.264文件的63页，这里展示常用的</p><ul><li>5,Coded slice of an IDR picture (I帧)</li><li>6,Supplemental enhancement information (SEI)</li><li>7,Sequence parameter set (SPS) </li><li>8,Picture parameter set (PPS)</li><li>24,Single-Time Aggregation Packet(STAP-A)</li></ul><p>从抓包看到SPS算上payload的长度为30，PPS算上payload的长度为4。不知道长度是不是固定的。</p><h5 id="STAP-A"><a href="#STAP-A" class="headerlink" title="STAP-A"></a>STAP-A</h5><p>STAP-A是多个NALU的聚合(Aggregation)，即这个NALU的payload里是多个NALU。STAP-A类型的NAL用来发送PPS/SPS/SEI等多种聚合。因为这些单元都很小。STRAP-A类型的header也是一个字节，但是payload里面有多个NALU，并且每个NALU前面用2字节来表示这个NALU的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|STAP-A header|NALU-1 size|NALU-1|NALU-2 size|NALU-2|</span><br></pre></td></tr></table></figure><p>NALU-1中又有header和payload。</p><h4 id="AVCC和AnnexB"><a href="#AVCC和AnnexB" class="headerlink" title="AVCC和AnnexB"></a>AVCC和AnnexB</h4><p>上面说了规范没有定义怎么保存NALU，所以有了这两个格式，他们两是平等关系，只有保存的格式不同而已。AVCC用来保存，annexB用来流传输。</p><ul><li>AVCC用1~4个字节来表示NALU的长度，长度后面是NALU。读取方法是先读长度，再读取NALU。再读下一个长度，再读下一个NALU…</li><li>而annexb用<code>0x00,0x00,0x00,0x01</code>或者<code>0x00,0x00,0x01</code>的起始码(start code)来分隔不同的NALU，所以方法是先读起始码，再一直读，直到发现下一个起始码，表示这个NALU结束，下一个NALU开始。</li></ul><p>ffmpeg使用中发现，AVCC一般用4字节表示NALU的长度，具体多少字节，在ffmpeg的extradata中有定义。annexB也是用4字节的起始码，也就是0x00,0x00,0x00,0x01。</p><h4 id="Fragmentation-Units-FUs-分片"><a href="#Fragmentation-Units-FUs-分片" class="headerlink" title="Fragmentation Units (FUs) 分片"></a>Fragmentation Units (FUs) 分片</h4><p>FU就是网络分片，因为I帧是一个完整的图片，所以非常大，为了保证udp不丢包，所以要分次发送。 第一个分片的FU的头设置了Start bit， 最后一个分片的FU头设置了END bit。分片是在rtp muxer中完成，注意ffmpeg中一个packet可以包含多个音频帧，但是只包含一个帧，直到发送rtp之前，一个packet总是完整的一帧视频（I/P/B）。 对于比较小的packet，例如聚合了PPS/SPS等信息的STAP-A包，不需要分片。</p><h4 id="extradata"><a href="#extradata" class="headerlink" title="extradata"></a>extradata</h4><p>上面很多次提到ffmpeg的extradata, 就是AVCodecParameters.extradata，它的长度是AVCodecParameters.extradata_size。在读取mp4文件的时候，ffmpeg会自动填充，在解码rtp的时候可能就需要手动填充了。extradata的比特位如下，首先是6字节的头，然后是多个SPS类型的NALU（2字节的长度分割多个NALU），再然后是PPS类型的NALU个数，最后是PPS类型的多个NALU(2字节的长度分割多个NALU）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bits    </span><br><span class="line">8   version ( always 0x01 )</span><br><span class="line">8   avc profile ( sps[0][1] )</span><br><span class="line">8   avc compatibility ( sps[0][2] )</span><br><span class="line">8   avc level ( sps[0][3] )</span><br><span class="line">6   reserved ( all bits on )</span><br><span class="line">2   NALULengthSizeMinusOne</span><br><span class="line">3   reserved ( all bits on )</span><br><span class="line">5   number of SPS NALUs (usually 1)</span><br><span class="line"></span><br><span class="line">repeated once per SPS:</span><br><span class="line">  16         SPS size</span><br><span class="line">  variable   SPS NALU data</span><br><span class="line"></span><br><span class="line">8   number of PPS NALUs (usually 1)</span><br><span class="line"></span><br><span class="line">repeated once per PPS:</span><br><span class="line">  16       PPS size</span><br><span class="line">  variable PPS NALU data</span><br></pre></td></tr></table></figure><p>里面包含了一个或多个PPS/SPS(NALU)，但保存的格式，既不是AVCC也不是AnnexB。因为上面可知AVCC用1<del>4个字节表示NALU的长度，AnnexB用3</del>4字节的起始码，而extradata是有一个6字节的header，里面有个字段叫<code>NALULengthSizeMinusOne</code>就是定义了AVCC使用多少个字节来表示NALU的长度。如果<code>NALULengthSizeMinusOne</code>等于0，那么AVCC用1字节表示NALU的长度。通常就是用4字节。</p><h5 id="extradata例子"><a href="#extradata例子" class="headerlink" title="extradata例子"></a>extradata例子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x &#x2F;150bx fmt_ctx-&gt;streams[0]-&gt;codecpar-&gt;extradata</span><br><span class="line">0x55555571d9c0: 0x01    0x64    0x00    0x28    0xff    0xe1    0x00    0x1e</span><br><span class="line">0x55555571d9c8: 0x67    0x64    0x00    0x28    0xac    0xd1    0x00    0x78</span><br><span class="line">0x55555571d9d0: 0x02    0x27    0xe5    0xc0    0x5a    0x80    0x80    0x80</span><br><span class="line">0x55555571d9d8: 0xa0    0x00    0x00    0x03    0x00    0x20    0x00    0x00</span><br><span class="line">0x55555571d9e0: 0x07    0x81    0xe3    0x06    0x22    0x40    0x01    0x00</span><br><span class="line">0x55555571d9e8: 0x04    0x68    0xeb    0xef    0x2c    0x00    0x00    0x00</span><br><span class="line">0x55555571d9f0: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571d9f8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da00: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da08: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da10: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da18: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da20: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da28: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da30: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da38: 0xc1    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x55555571da40: 0x9d    0xad    0x00    0x00    0x50    0x55    0x00    0x00</span><br><span class="line">0x55555571da48: 0xfa    0x19    0xc4    0x92    0x40    0xa0    0xdc    0xba</span><br><span class="line">0x55555571da50: 0x00    0x00    0x00    0x00    0x00    0x00</span><br></pre></td></tr></table></figure><ul><li>第5字节0xff,二进制为:1111 1111, 后2位表示<code>NALULengthSizeMinusOne</code>=3，所以ffmpeg用4字节表示NALU的大小（AVCC格式）。</li><li>第6字节0xe1,二进制为:1110 0001，后5位表示SPS的个数=1,所以只有一个SPS。</li><li>第7，8字节表示SPS的长度，0x00，0x1e，二进制为:0000 0000, 0001 1110，所以SPS长度为30。</li><li>跳过30个字节，0x01，二进制为:0000 0001, 表示有1个PPS。</li><li>后面的2个字节，0x00,0x04,二进制为:0000,0004,表示PPS的长度为4个字节。</li></ul><h5 id="NALU头的解析"><a href="#NALU头的解析" class="headerlink" title="NALU头的解析"></a>NALU头的解析</h5><p>NALU头是1字节，第一位F bit, 后两位NRI bit, 后五位表示NALU的type。</p><p>SPS的头是0x67，而进制为: 01100111，所以type值正好是7。<br>PPS的头是0x68，而进制为: 01101000，所以type值正好是8。</p><p>对比wireshark解析结果可以确认上面的理解正确，可见extradata就是6个字节的header加多个AVCC格式的NALU。</p><h5 id="创建extradata"><a href="#创建extradata" class="headerlink" title="创建extradata"></a>创建extradata</h5><p>rtp解码时，需要手动生成extradata。创建AVCC格式的extradata</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">write(0x1);  &#x2F;&#x2F; version</span><br><span class="line">write(sps[0].data[1]); &#x2F;&#x2F; profile</span><br><span class="line">write(sps[0].data[2]); &#x2F;&#x2F; compatibility</span><br><span class="line">write(sps[0].data[3]); &#x2F;&#x2F; level</span><br><span class="line">write(0xFC | 3); &#x2F;&#x2F; reserved (6 bits), NULA length size - 1 (2 bits)</span><br><span class="line">write(0xE0 | 1); &#x2F;&#x2F; reserved (3 bits), num of SPS (5 bits)</span><br><span class="line">write_word(sps[0].size); &#x2F;&#x2F; 2 bytes for length of SPS</span><br><span class="line">for(size_t i&#x3D;0 ; i &lt; sps[0].size ; ++i)</span><br><span class="line">  write(sps[0].data[i]); &#x2F;&#x2F; data of SPS</span><br><span class="line"></span><br><span class="line">write(&amp;b, pps.size());  &#x2F;&#x2F; num of PPS</span><br><span class="line">for(size_t i&#x3D;0 ; i &lt; pps.size() ; ++i) &#123;</span><br><span class="line">  write_word(pps[i].size);  &#x2F;&#x2F; 2 bytes for length of PPS</span><br><span class="line">  for(size_t j&#x3D;0 ; j &lt; pps[i].size ; ++j)</span><br><span class="line">    write(pps[i].data[j]);  &#x2F;&#x2F; data of PPS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建annexB格式的extradata</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">write(0x00)</span><br><span class="line">write(0x00)</span><br><span class="line">write(0x00)</span><br><span class="line">write(0x01)</span><br><span class="line">for each byte b in SPS</span><br><span class="line">  write(b)</span><br><span class="line"></span><br><span class="line">for each PPS p in PPS_array</span><br><span class="line">  write(0x00)</span><br><span class="line">  write(0x00)</span><br><span class="line">  write(0x00)</span><br><span class="line">  write(0x01)</span><br><span class="line">  for each byte b in p</span><br><span class="line">    write(b)</span><br></pre></td></tr></table></figure><h2 id="wireshark解析"><a href="#wireshark解析" class="headerlink" title="wireshark解析"></a>wireshark解析</h2><p>从wiresshark对比用bsf和不用bsf的抓包发现，SEI包的内容没有变化，是不是可以不需要转成annexb，直接将PPS/SPS直接拷贝到packet中发出去呢？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://membrane.stream/learn/h264/3" target="_blank" rel="noopener">https://membrane.stream/learn/h264/3</a><br><a href="https://github.com/cisco/openh264/issues/2501#issuecomment-231340268" target="_blank" rel="noopener">https://github.com/cisco/openh264/issues/2501#issuecomment-231340268</a><br><a href="https://stackoverflow.com/questions/17667002/how-to-add-sps-pps-read-from-mp4-file-information-to-every-idr-frame" target="_blank" rel="noopener">https://stackoverflow.com/questions/17667002/how-to-add-sps-pps-read-from-mp4-file-information-to-every-idr-frame</a><br><a href="https://stackoverflow.com/questions/24884827/possible-locations-for-sequence-picture-parameter-sets-for-h-264-stream" target="_blank" rel="noopener">https://stackoverflow.com/questions/24884827/possible-locations-for-sequence-picture-parameter-sets-for-h-264-stream</a><br><a href="https://aviadr1.blogspot.com/2010/05/h264-extradata-partially-explained-for.html" target="_blank" rel="noopener">https://aviadr1.blogspot.com/2010/05/h264-extradata-partially-explained-for.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里记录了使用ffmpeg来发送h264的rtp流，主要问题是处理pps和sps的发送，看了非常多的文档和例子包括gptchat，直到用gdb跟ffmpeg才找到解决办法。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="ffmpeg" scheme="https://energygreek.github.io/tags/ffmpeg/"/>
    
    <category term="rtp" scheme="https://energygreek.github.io/tags/rtp/"/>
    
  </entry>
  
  <entry>
    <title>随身wifi工具</title>
    <link href="https://energygreek.github.io/2023/09/08/wifi-tool/"/>
    <id>https://energygreek.github.io/2023/09/08/wifi-tool/</id>
    <published>2023-09-08T07:34:43.000Z</published>
    <updated>2024-02-07T09:59:29.791Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了淘宝卖的随身wifi刷机成Debian，还能收发短信。还有救砖的艰辛过程，不过结局美满。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>edl备份恢复工具，<a href="https://github.com/bkerler/edl" target="_blank" rel="noopener">https://github.com/bkerler/edl</a>, 下载源代码后执行<code>git submodule update --init --recursive</code>和 <code>pip install -r requirements.txt</code></li><li>openstick编译好的debian <a href="https://github.com/OpenStick/OpenStick。" target="_blank" rel="noopener">https://github.com/OpenStick/OpenStick。</a> 在release页面下载 base.zip, debian.zip, firmware-ufi001c.zip，boot-ufi001c.img</li><li>apt 安装 adb fastboot</li></ul><h2 id="切卡"><a href="#切卡" class="headerlink" title="切卡"></a>切卡</h2><p>刚接触时看网上的都是在后台页面切卡，但是刷机了没有后台页面如何切卡呢？ 为了切卡又重刷安卓，导致变砖了。参考网上资料发现，Debian下可以直接切。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">debian默认卡槽位1:</span><br><span class="line"></span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel2&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en2&#x2F;brightnessR</span><br><span class="line">modprobe -r qcom-q6v5-mss</span><br><span class="line">modprobe qcom-q6v5-mss</span><br><span class="line">systemctl restart rmtfs</span><br><span class="line">systemctl restart dbus-org.freedesktop.ModemManager1.service</span><br><span class="line"></span><br><span class="line">esim槽位3:</span><br><span class="line"></span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en&#x2F;brightness</span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel2&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en2&#x2F;brightness</span><br><span class="line">modprobe -r qcom-q6v5-mss</span><br><span class="line">modprobe qcom-q6v5-mss</span><br><span class="line">systemctl restart rmtfs</span><br><span class="line">systemctl restart dbus-org.freedesktop.ModemManager1.service</span><br><span class="line"></span><br><span class="line">其他两个槽位</span><br><span class="line"></span><br><span class="line">槽位2:</span><br><span class="line"></span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel&#x2F;brightness</span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel2&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en2&#x2F;brightness</span><br><span class="line">modprobe -r qcom-q6v5-mss</span><br><span class="line">modprobe qcom-q6v5-mss</span><br><span class="line">systemctl restart rmtfs</span><br><span class="line">systemctl restart dbus-org.freedesktop.ModemManager1.service</span><br><span class="line"></span><br><span class="line">槽位4:</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en&#x2F;brightness</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:sel2&#x2F;brightness</span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;leds&#x2F;sim:en2&#x2F;brightness</span><br><span class="line">modprobe -r qcom-q6v5-mss</span><br><span class="line">modprobe qcom-q6v5-mss</span><br><span class="line">systemctl restart rmtfs</span><br><span class="line">systemctl restart dbus-org.freedesktop.ModemManager1.service</span><br><span class="line"></span><br><span class="line">有些棒子esim槽位不一样槽位3不行自行试试槽位2 4</span><br></pre></td></tr></table></figure><p><a href="https://github.com/OpenStick/OpenStick/issues/49#issuecomment-1568202001" target="_blank" rel="noopener">https://github.com/OpenStick/OpenStick/issues/49#issuecomment-1568202001</a></p><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>先使用edl全量备份，方法在最下面。先刷base包，解压base.zip后执行里面的<code>flash.sh</code>。然后刷debian包，解压debian.zip后执行里面的<code>flash.sh</code>。这时进入系统发现可能出现问题（我也没明显感觉到问题），因为他们是ufi001b的。<br>所以再刷适配ufi001c的包，解压firmware-ufi001c.zip。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd firmware-ufi001c</span><br><span class="line">adb push .&#x2F;* &#x2F;lib&#x2F;firmware</span><br><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash boot boot-ufi001c.img</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><p>但是在刷ufi001c的包之前我能找到modem网络，刷完就没了，所以有了下面基带恢复的步骤。</p><h2 id="基带"><a href="#基带" class="headerlink" title="基带"></a>基带</h2><p>基带文件在随身wifi的modem分区，先用edl备份modem分区。当然下面介绍了edl全量备份，跳过了userdata，估计是root和home目录。</p><h3 id="恢复基带文件"><a href="#恢复基带文件" class="headerlink" title="恢复基带文件"></a>恢复基带文件</h3><p>我在安装debian系统时，发现移动网络不可用，于是参考网上说的，将原始基带恢复后正常。 基带文件名为”modem.bin”, edl全量备份后在dumps目录下。直接mount该文件，然后将modem.*和mba.mbn取出来，当发现刷机后发现移动网络不能使用时，重新拷回去就能用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount modem.bin &#x2F;mnt</span><br></pre></td></tr></table></figure><p>复制到firmware-ufi001c目录，覆盖之前的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;mnt&#x2F;modem.* .</span><br><span class="line">cp &#x2F;mnt&#x2F;mba.mbn .</span><br></pre></td></tr></table></figure><p>再次拷贝到wifi棒子的/lib/firmware目录, 配合再刷一次适配001C的boot文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb push .&#x2F;* &#x2F;lib&#x2F;firmware</span><br><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash boot boot-ufi001c.img</span><br><span class="line">fastboot reboot #重启</span><br></pre></td></tr></table></figure><p>然后就能找到modem网卡了。</p><h2 id="重启modem"><a href="#重启modem" class="headerlink" title="重启modem"></a>重启modem</h2><p>有时重刷了firmware，还是出现没有modem网卡的情况，也就是<code>mmcli -m 0</code>提示找不到modem设备的时候，需要执行下面的命令。或者直接等一会重启ModemManager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop ModemManager</span><br><span class="line">qmicli -d &#x2F;dev&#x2F;wwan0qmi0 --uim-sim-power-off&#x3D;1 &amp;&amp; qmicli -d &#x2F;dev&#x2F;wwan0qmi0 --uim-sim-power-on&#x3D;1</span><br><span class="line">systemctl start ModemManager</span><br></pre></td></tr></table></figure><h2 id="短信收发和转发邮件"><a href="#短信收发和转发邮件" class="headerlink" title="短信收发和转发邮件"></a>短信收发和转发邮件</h2><p>下载两个python文件，地址 <a href="https://gitee.com/jiu-xiao/ufi-message。配置smtp.py中的邮箱信息，我使用的QQ邮箱登录，然后转发到另一个邮箱。开始发送不成功，修改后能发送了，内容如下。" target="_blank" rel="noopener">https://gitee.com/jiu-xiao/ufi-message。配置smtp.py中的邮箱信息，我使用的QQ邮箱登录，然后转发到另一个邮箱。开始发送不成功，修改后能发送了，内容如下。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!python3</span><br><span class="line"></span><br><span class="line">my_sender&#x3D;&#39;@qq.com&#39;</span><br><span class="line">my_user&#x3D;&#39;@hotmail.com&#39;</span><br><span class="line">server_address&#x3D;&#39;smtp.qq.com&#39;</span><br><span class="line">server_port&#x3D;465</span><br><span class="line">server_passwd&#x3D;&#39;&#39; #填写qq邮箱授权码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.utils import formataddr</span><br><span class="line">import datetime</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def mail(text):</span><br><span class="line">    msg&#x3D;MIMEText(text,&#39;plain&#39;,&#39;utf-8&#39;)</span><br><span class="line">    msg[&#39;From&#39;]&#x3D;formataddr([&quot;随身Wifi&quot;,my_sender])</span><br><span class="line">    msg[&#39;To&#39;]&#x3D;formataddr([my_user,my_user])</span><br><span class="line">    msg[&#39;Subject&#39;]&#x3D;&quot;转发 &quot;+time.strftime(&quot;%H:%%M:%S %m&#x2F;%d&quot;)</span><br><span class="line"></span><br><span class="line">    server&#x3D;smtplib.SMTP_SSL(server_address,server_port)</span><br><span class="line"></span><br><span class="line">    server.login(my_sender,server_passwd)</span><br><span class="line">    server.auth_plain()</span><br><span class="line">    server.sendmail(my_sender,[my_user,],msg.as_string())</span><br><span class="line">    server.quit()</span><br></pre></td></tr></table></figure><p>然后就能写进crontab自动跑了。</p><h2 id="救砖"><a href="#救砖" class="headerlink" title="救砖"></a>救砖</h2><h3 id="edl使用"><a href="#edl使用" class="headerlink" title="edl使用"></a>edl使用</h3><p>github上的开源工具，可以替代Windows那些高通工具，Miko，星海啥的。是我这Linux用户的福音，并且简单，windows常常失败。<br>使用edl工具之前要先重启到edl也就是9008模式，使用命令<code>adb reboot edl</code>，不需要按RST键。</p><p>备份：推荐第一种方式，第二种方式生成的一个文件刷到另一个设备失败，但是可以刷MiKo导出的单文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edl rl dumps --skip&#x3D;userdata --genxml</span><br><span class="line">or</span><br><span class="line">edl rf flash.bin #单文件</span><br></pre></td></tr></table></figure><p>恢复:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edl qfil rawprogram0.xml patch0.xml .</span><br></pre></td></tr></table></figure><h3 id="恢复分区"><a href="#恢复分区" class="headerlink" title="恢复分区"></a>恢复分区</h3><p>刷了debian后，分区会变，这样导致有些分区不存在所以无法刷回去。这里介绍下恢复分区的方法。不过上面的edl恢复应该不需要这个操作。</p><p>备份分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;edl gpt . --genxml</span><br></pre></td></tr></table></figure><p>备份后有两个文件，恢复时只用gpt_main0.bin文件，恢复分区命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;edl w gpt gpt_main0.bin</span><br></pre></td></tr></table></figure><p>打印分区来验证下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;edl printgpt</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://forum.openwrt.org/t/uf896-qualcomm-msm8916-lte-router-384mib-ram-2-4gib-flash-android-openwrt/131712/160" target="_blank" rel="noopener">https://forum.openwrt.org/t/uf896-qualcomm-msm8916-lte-router-384mib-ram-2-4gib-flash-android-openwrt/131712/160</a><br><a href="https://www.kancloud.cn/handsomehacker/openstick/2636505" target="_blank" rel="noopener">https://www.kancloud.cn/handsomehacker/openstick/2636505</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文记录了淘宝卖的随身wifi刷机成Debian，还能收发短信。还有救砖的艰辛过程，不过结局美满。&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;edl备份恢复</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker network</title>
    <link href="https://energygreek.github.io/2023/07/21/docker-network/"/>
    <id>https://energygreek.github.io/2023/07/21/docker-network/</id>
    <published>2023-07-21T07:55:38.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次docker的网络问题，以及学到的知识。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司用docker容器替代虚拟机来隔离，用来ssh登录以及运行不同的服务。容器连接了双网络，一个用来访问同宿主机上的容器，另一个用来从其他主机访问。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>宿主机重启之后，容器无法访问。需要手动改路由。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>每次修改路由麻烦，后面发现两个网络都是macvlan时，存在无法没有网络。</p><h2 id="创建桥接物理网卡"><a href="#创建桥接物理网卡" class="headerlink" title="创建桥接物理网卡"></a>创建桥接物理网卡</h2><p>这是需要指定parent为物理网卡，既然是桥接物理网卡，就能从其他宿主机访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge   --subnet&#x3D;10.9.3.0&#x2F;24   --gateway&#x3D;10.9.3.1   -o parent&#x3D;ens39f0 public_net_bridge</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan  --subnet&#x3D;10.9.3.0&#x2F;24   --gateway&#x3D;10.9.3.1   -o parent&#x3D;ens39f0 public_net_macvlan</span><br></pre></td></tr></table></figure><p>这两个由于使用的同一个网段/网卡，所以不可能同时存在。也许可以通过指定不同的ip-range来实现吗？</p><h2 id="创建桥接虚拟网卡"><a href="#创建桥接虚拟网卡" class="headerlink" title="创建桥接虚拟网卡"></a>创建桥接虚拟网卡</h2><p>这种网络就不能从非宿主机的其他主机访问，只能在同宿机下的容器之间访问。我称之为私有网络 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge   private_net_bridge</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan  private_net_macvlan</span><br></pre></td></tr></table></figure><p>这里没有指定网络地址</p><h2 id="iperf测速"><a href="#iperf测速" class="headerlink" title="iperf测速"></a>iperf测速</h2><p>发现无论桥接物理网卡还是虚拟网卡，macvlan都要比bridge快</p><ul><li><p>私有网络<br>bridge 模式分别测得: 20.4 Gbits/sec 22.6 Gbits/sec 23.0 Gbits/sec<br>macvlan 模式分别测得: 26.1 Gbits/sec 24.4 Gbits/sec 26.7 Gbits/sec</p></li><li><p>桥接物理网卡<br>macvlan: 25.7 Gbits/sec 25.5 Gbits/sec 27.3 Gbits/sec<br>bridge: 20.2 Gbits/sec 20.4 Gbits/sec 23.2 Gbits/sec</p></li></ul><h2 id="顺便说下容器连接多网络的方法"><a href="#顺便说下容器连接多网络的方法" class="headerlink" title="顺便说下容器连接多网络的方法"></a>顺便说下容器连接多网络的方法</h2><p>容器启动的时候，只能指定一个网络, 然后启动之后，可以通过命令来连接多网络，可以在启动时设置–restart=alway,这样重启主机后自动连接双网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect private_net_bridge test_container</span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>网络配置挺复杂，macvlan 下面还分</p><ul><li>Bridge mode, 就是常见的模式，走宿主机的网卡</li><li>802.1q trunk bridge mode, 先在物理网卡上创建子网卡</li></ul><h3 id="IPvlan"><a href="#IPvlan" class="headerlink" title="IPvlan"></a>IPvlan</h3><p>除了bridge macvlan之外，还有IPvlan, 这种模式下，所有的容器都使用相同的mac地址，所以如果容器使用dhcp来获取ip地址，则可能有问题。 访问其他容器时，可以配置来使用macvlan模式。</p><h3 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h3><p>docker network driver 除了上面的三种模式之外，还有overlay, 用于连接不同主机的网络，可以跨宿主机访问容器。</p><h2 id="宿主机网络类型"><a href="#宿主机网络类型" class="headerlink" title="宿主机网络类型"></a>宿主机网络类型</h2><p>我通常会创建bridge并将物理网卡设为从卡，然后创建虚拟网桥，用于访问虚拟机。而除了bridge, 还有bond,另外还有team。总而言之，bridge可以使不同的虚拟机（client）使用网卡的虚拟化功能，而bond可以将不同的网卡绑定，实现负载均衡。如果两个网卡分别有1M带宽，那么bond后的网卡则有2M带宽。下面的链接先bonding,然后在bonding网卡上创建bridge网卡。<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/networking_guide/sec-vlan_on_bond_and_bridge_using_the_networkmanager_command_line_tool_nmcli" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一次docker的网络问题，以及学到的知识。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司用docker容器替代虚拟机来隔离，用来ssh登录以及运行不同的服务。容</summary>
      
    
    
    
    
    <category term="docker" scheme="https://energygreek.github.io/tags/docker/"/>
    
    <category term="network" scheme="https://energygreek.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>mail setup</title>
    <link href="https://energygreek.github.io/2023/07/18/mail-setup/"/>
    <id>https://energygreek.github.io/2023/07/18/mail-setup/</id>
    <published>2023-07-18T10:24:55.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下的邮件配置"><a href="#Linux下的邮件配置" class="headerlink" title="Linux下的邮件配置"></a>Linux下的邮件配置</h1><p>这里记录Linux（debian）下如何使用Mutt查看邮件，用fetchmail接收邮件，用msmtp发送邮件以及使用maildrop来筛选邮件。与其他邮件客户端相比，如thunderbird，他们使用的在线登陆方式，没有下载邮件来离线访问。而mutt支持离线访问本地的邮件，也可以配置为访问邮件服务器，查看服务器上的邮件。 在线方式除了离线不可用的缺点之外，每次打开mutt需要登陆，非常慢。<br>我这里的配置是比较简陋，适合公司少量邮件的场景。又因为目前使用的Byobu-terminal终端，其邮件提醒是基于/var/mail/spool/$USER文件。邮件比较多或者附件比较大的话，相较于用文件夹来存储邮件，这种方式会比较慢。</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>需要安装 fetchmail, maildrop, mutt</p><h2 id="接收配置"><a href="#接收配置" class="headerlink" title="接收配置"></a>接收配置</h2><p>在家目录下创建文件.fetchmailrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">poll imap.exmail.qq.com</span><br><span class="line">  protocol IMAP</span><br><span class="line">  user &quot;example@example.com&quot;</span><br><span class="line">  password &quot;password&quot;</span><br><span class="line">  keep</span><br><span class="line">  #fetchall</span><br><span class="line">  ssl</span><br><span class="line"></span><br><span class="line">mimedecode</span><br><span class="line">mda &quot;&#x2F;usr&#x2F;bin&#x2F;maildrop&quot;</span><br></pre></td></tr></table></figure><p>keep 方式不会删除服务器上的邮件。然后启动定时任务，自动检查新邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --user enable --now fetchmail.service</span><br></pre></td></tr></table></figure><h2 id="发送配置"><a href="#发送配置" class="headerlink" title="发送配置"></a>发送配置</h2><p>在家目录创建文件.msmtproc，填入发送的验证信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">defaults</span><br><span class="line">auth           on</span><br><span class="line">tls            on</span><br><span class="line">tls_starttls off</span><br><span class="line">tls_trust_file &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;ca-certificates.crt</span><br><span class="line">logfile        ~&#x2F;.msmtp.log</span><br><span class="line"></span><br><span class="line"># exmail</span><br><span class="line">account        office</span><br><span class="line">host           smtp.exmail.qq.com</span><br><span class="line">port           465</span><br><span class="line">from           example@example.com</span><br><span class="line">user           example@example.com</span><br><span class="line">password       password</span><br></pre></td></tr></table></figure><h2 id="mutt配置"><a href="#mutt配置" class="headerlink" title="mutt配置"></a>mutt配置</h2><p>由于我不想删除/var/mail/里面的邮件，这样才能在byobu-terminal中提醒，所以没有配置maildrop。最后需要配置mutt读取/var/mail/$USER。在家目录或者xdg配置目录（~/.config/mutt）创建文件.muttrc/muttrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set spoolfile&#x3D;&#x2F;var&#x2F;spool&#x2F;mail&#x2F;jimery</span><br><span class="line">set header_cache&#x3D;~&#x2F;.cache&#x2F;mutt</span><br><span class="line">set send_charset&#x3D;&quot;utf-8&quot;</span><br></pre></td></tr></table></figure><p>这样就能查看邮件了。 在mutt里面手动管理邮件，存档或者删除。</p><h2 id="mutt使用"><a href="#mutt使用" class="headerlink" title="mutt使用"></a>mutt使用</h2><p>其实不用mutt, 直接用mail也可以，这个默认访问/var/mail/$USER,是Linux默认的邮件工具。 mutt能很方便调用msmtproc来发送邮件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux下的邮件配置&quot;&gt;&lt;a href=&quot;#Linux下的邮件配置&quot; class=&quot;headerlink&quot; title=&quot;Linux下的邮件配置&quot;&gt;&lt;/a&gt;Linux下的邮件配置&lt;/h1&gt;&lt;p&gt;这里记录Linux（debian）下如何使用Mutt查看邮件，用fe</summary>
      
    
    
    
    
    <category term="email_client" scheme="https://energygreek.github.io/tags/email-client/"/>
    
    <category term="mutt" scheme="https://energygreek.github.io/tags/mutt/"/>
    
  </entry>
  
  <entry>
    <title>install wordpress</title>
    <link href="https://energygreek.github.io/2023/07/08/install-wordpress/"/>
    <id>https://energygreek.github.io/2023/07/08/install-wordpress/</id>
    <published>2023-07-08T09:03:12.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装wordpress记录"><a href="#安装wordpress记录" class="headerlink" title="安装wordpress记录"></a>安装wordpress记录</h1><p>本文记录在debian上安装配置wordpress的补助，并配置了ftp功能，支持自更新wordpress。</p><h2 id="安装wordpress"><a href="#安装wordpress" class="headerlink" title="安装wordpress"></a>安装wordpress</h2><p>下载最新的包，解压到<code>/var/www/html</code></p><h2 id="安装配置数据库"><a href="#安装配置数据库" class="headerlink" title="安装配置数据库"></a>安装配置数据库</h2><p>安装mariadb, 创建数据库和用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">CREATE DATABASE wordpressdb; </span><br><span class="line">CREATE USER wordpressuser@localhost IDENTIFIED BY &#39;password&#39;;</span><br><span class="line">GRANT ALL PRIVILEGES ON wordpressdb.* TO wordpressuser@localhost;</span><br></pre></td></tr></table></figure><h2 id="安装配置nginx-php"><a href="#安装配置nginx-php" class="headerlink" title="安装配置nginx php"></a>安装配置nginx php</h2><p>安装nginx和php-7.4，还有php一些组件<br>nginx 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">  listen 80 default_server; </span><br><span class="line">  listen [::]:80 default_server;</span><br><span class="line">  server_name your_domain.com;</span><br><span class="line"></span><br><span class="line">  root &#x2F;var&#x2F;www&#x2F;html;</span><br><span class="line">  index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    # try_files $uri $uri&#x2F; &#x3D;404;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.php?q&#x3D;$uri&amp;$args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ~ \.php$ &#123;</span><br><span class="line">      include snippets&#x2F;fastcgi-php.conf;</span><br><span class="line">      fastcgi_split_path_info ^(.+\.php)(&#x2F;.+)$;</span><br><span class="line">      fastcgi_pass unix:&#x2F;run&#x2F;php&#x2F;php-fpm.sock;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装配置vsftpd"><a href="#安装配置vsftpd" class="headerlink" title="安装配置vsftpd"></a>安装配置vsftpd</h2><p>安装后，修改配置文件<code>/etc/vsftpd.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local_enable&#x3D;YES</span><br><span class="line">write_enable&#x3D;YES</span><br><span class="line">chroot_local_user&#x3D;YES</span><br><span class="line">chroot_list_enable&#x3D;YES</span><br><span class="line">chroot_list_file&#x3D;&#x2F;etc&#x2F;vsftpd.chroot_list</span><br><span class="line">allow_writeable_chroot&#x3D;YES</span><br><span class="line">pm_service_name&#x3D;ftp</span><br></pre></td></tr></table></figure><h3 id="添加用户，并限制权限"><a href="#添加用户，并限制权限" class="headerlink" title="添加用户，并限制权限"></a>添加用户，并限制权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useradd [user_name]</span><br><span class="line">passwd [user_name]</span><br><span class="line">usermod -d &#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress user_name -s &#x2F;sbin&#x2F;nologin</span><br><span class="line"></span><br><span class="line">setfacl -m u:ftpsecure:r-x &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line"></span><br><span class="line">setfacl -R -m u:ftpsecure:rwx &#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress</span><br><span class="line">setfacl -R -d -m u:ftpsecure:rwx &#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress</span><br></pre></td></tr></table></figure><p>如果提示没有setfacl命令，则执行安装acl命令 <code>apt install acl</code></p><h3 id="ftp遇到问题和解决办法"><a href="#ftp遇到问题和解决办法" class="headerlink" title="ftp遇到问题和解决办法"></a>ftp遇到问题和解决办法</h3><ul><li><p>登陆提示”500 OOPS: could not read chroot() list file:/etc/vsftpd.chroot_list”，需要创建文件<code>/etc/vsftpd.chroot_list</code></p></li><li><p>登陆ftp报530验证失败的问题，修改配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm_service_name&#x3D;ftp</span><br></pre></td></tr></table></figure></li><li><p>登陆提示”500 OOPS: vsftpd: refusing to run with writable root inside chroot()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow_writeable_chroot&#x3D;YES</span><br></pre></td></tr></table></figure><ul><li>登陆提示 500 OOPS: vsftpd: refusing to run with writable root ，意思是登陆者具备对目录的写权限，这是由于目录设定权限为777，所以要是重新设定为755<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 &#x2F;srv&#x2F;ftp</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置wordpress"><a href="#配置wordpress" class="headerlink" title="配置wordpress"></a>配置wordpress</h2><p>修改<code>wordpress/wp-config.php</code> 文件, 添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(&#39;FTP_HOST&#39;, &#39;localhost&#39;);</span><br><span class="line">define(&#39;FTP_USER&#39;, &#39;ftp&#39;);</span><br><span class="line">define(&#39;FTP_PASS&#39;, &#39;&#39;);</span><br></pre></td></tr></table></figure><p>通过wordpress的api可以生成随机token，将输出替换到<code>wordpress/wp-config.php</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$curl -s https:&#x2F;&#x2F;api.wordpress.org&#x2F;secret-key&#x2F;1.1&#x2F;salt&#x2F;</span><br><span class="line"></span><br><span class="line">define(&#39;AUTH_KEY&#39;,         &#39;uOeyPW$K[P&#125;23x^0l##N+qP#xzUlIBV[ZQlATs!7J?+5^!w0*bgEw|V6)k:YU0en&#39;);</span><br><span class="line">define(&#39;SECURE_AUTH_KEY&#39;,  &#39;Ad*-&#96;eK|U4Z*7g&#125;7CdX&lt;q0^EuGqT1Tt&#125;CaDRgF%NX-|fmk(:BACtws+^_0Pb8ZRA&#39;);</span><br><span class="line">define(&#39;LOGGED_IN_KEY&#39;,    &#39;:Z$&#125;&#x3D;h~z-[]8W&#125;wZ(|&#x2F;;]ZY;U&#123;&gt;u3K&gt;P|u6&#x2F;d:6&#125;&amp;h*);0ewhrcGm8$&#x2F;tPii#&#123;,%&#39;);</span><br><span class="line">define(&#39;NONCE_KEY&#39;,        &#39;d&#125;Ue8.+KPDGdH^%2t~fTljDj8e&#123;q&#123;raR!Q0piqM(gcQP&amp;7-$L3u0u|!Bn(-gh&#x2F;?B&#39;);</span><br><span class="line">define(&#39;AUTH_SALT&#39;,        &#39;UQh.k&gt;4UBTK6IecZe~lL6|J&#x2F;w^KFROIeCdZw^g&#x3D;(x?(L+j(-|%C FCt &#x3D;V*XVz+k&#39;);</span><br><span class="line">define(&#39;SECURE_AUTH_SALT&#39;, &#39;hHr&amp;dDCApb14yz@ks+;&#125;mk,s&lt;-[]KUj*UAhl0+&lt;pqT*!j;wxc+[mU[czh &#x3D;&gt;&lt;#em&#39;);</span><br><span class="line">define(&#39;LOGGED_IN_SALT&#39;,   &#39;WO,U^A||&amp;:E@2A2_|MS W1l&#96;fguj-7E&#123;Fz6QkC+OM96Ho49&lt;agM?O&#x3D;G2FloxuF?6&#39;);</span><br><span class="line">define(&#39;NONCE_SALT&#39;,       &#39;uDN.1::MJ&gt;~9Yp+e39y%o?r &gt;:+OcUSqg5_g&lt;Jt:Sr!um?U:U|MJ2q2qKiLDfmr@&#39;);</span><br></pre></td></tr></table></figure><p>更新数据库配置到wp-config.php</p><h2 id="更新url"><a href="#更新url" class="headerlink" title="更新url"></a>更新url</h2><p>开始使用http访问，后面切换到https后一直提示错误说跳转太多次。后来发现原因是套了cloudflare，cloudflare设置的是前端https后端http, 后端以http访问真实服务器后又跳转到https。所以请求一直在cf&lt;-&gt;wordpress之间无限跳转。所以首先要设置cloudflare的代理模式为严格安全，strict full safe，也就是前端和后端都用证书。然后修改wordpress的url方法有很多，之前通过直接修改数据库，这次发现wordpress有个wp的命令行工具，一键修改。</p><h2 id="vsftpd-配置默认目录"><a href="#vsftpd-配置默认目录" class="headerlink" title="vsftpd 配置默认目录"></a>vsftpd 配置默认目录</h2><p>为local user配置默认目录，例如所有用户登录后进入/home目录, 添加配置<code>local_root=/home</code>，为匿名用户配置默认目录为tmp目录，则添加配置<code>anon_root=/tmp</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://serverfault.com/questions/544850/create-new-vsftpd-user-and-lock-to-specify-home-login-directory" target="_blank" rel="noopener">https://serverfault.com/questions/544850/create-new-vsftpd-user-and-lock-to-specify-home-login-directory</a><br><a href="https://shiftedbits.org/2012/01/29/enable-wordpress-automatic-updates-on-a-debian-server/" target="_blank" rel="noopener">https://shiftedbits.org/2012/01/29/enable-wordpress-automatic-updates-on-a-debian-server/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装wordpress记录&quot;&gt;&lt;a href=&quot;#安装wordpress记录&quot; class=&quot;headerlink&quot; title=&quot;安装wordpress记录&quot;&gt;&lt;/a&gt;安装wordpress记录&lt;/h1&gt;&lt;p&gt;本文记录在debian上安装配置wordpress的</summary>
      
    
    
    
    
    <category term="wordpress" scheme="https://energygreek.github.io/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>amrnb和amrwb的编解码</title>
    <link href="https://energygreek.github.io/2022/12/29/amrnb-and-amrwb/"/>
    <id>https://energygreek.github.io/2022/12/29/amrnb-and-amrwb/</id>
    <published>2022-12-29T01:15:46.000Z</published>
    <updated>2024-02-07T09:59:29.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>最近在公司开发一个amrnb/amrwb的转码工具，在网上看了很多资料，主要是这篇<a href="https://blog.csdn.net/runningya/article/details/6227384" target="_blank" rel="noopener">AMR在IP域中的编码(rfc3267,4867)</a> 对我帮助很大。 这里补充一下缺少和我自己的理解。</p><h2 id="AMR编码介绍"><a href="#AMR编码介绍" class="headerlink" title="AMR编码介绍"></a>AMR编码介绍</h2><p>AMR是3GPP组织的一个音频编码规范，目前的手机都使用AMR, 比如公司的测试机华为、小米只支持amrnb/amrwb。amrnb是对窄带信号进行编码（200–3400 Hz），amrwb是对更宽的频率范围进行编码（50–7000 Hz）。<br>根据香农理论，采样频率要是目标频率的两倍，所以向上取整的amrnb的采样频率是8000Hz, amrwb的采样频率是16000Hz。</p><h2 id="bitrate"><a href="#bitrate" class="headerlink" title="bitrate"></a>bitrate</h2><p>amrnb和amrwb有多种编码速率（bitrate），并支持在通话过程中通过CMR（codec mode request）协商来变化编码速率，不同于一般的编码器固定一种比特率。除此之外，还有没有人声时的SID（舒适噪音）模式。这时只需要发送一个Mode而不是发送无声的包，从而来降低带宽占用。</p><h3 id="amrnb-不同比特率时的语音帧大小"><a href="#amrnb-不同比特率时的语音帧大小" class="headerlink" title="amrnb 不同比特率时的语音帧大小"></a>amrnb 不同比特率时的语音帧大小</h3><table><thead><tr><th>Index</th><th>Mode</th><th>Class A bits</th><th>total speech bits</th></tr></thead><tbody><tr><td>0</td><td>4.75</td><td>42</td><td>95</td></tr><tr><td>1</td><td>5.15</td><td>49</td><td>103</td></tr><tr><td>2</td><td>5.9</td><td>55</td><td>118</td></tr><tr><td>3</td><td>6.7</td><td>58</td><td>134</td></tr><tr><td>4</td><td>7.4</td><td>61</td><td>148</td></tr><tr><td>5</td><td>7.95</td><td>75</td><td>159</td></tr><tr><td>6</td><td>10.2</td><td>65</td><td>204</td></tr><tr><td>7</td><td>12.2</td><td>81</td><td>244</td></tr></tbody></table><h3 id="amrwb-不同比特率的语音帧大小"><a href="#amrwb-不同比特率的语音帧大小" class="headerlink" title="amrwb 不同比特率的语音帧大小"></a>amrwb 不同比特率的语音帧大小</h3><table><thead><tr><th>Index</th><th>AMR-WB codec mode</th><th>Total number of bits</th><th>Class A Class B Class C</th></tr></thead><tbody><tr><td>0</td><td>6.60</td><td>132</td><td>54 78 0</td></tr><tr><td>1</td><td>8.85</td><td>177</td><td>64 113 0</td></tr><tr><td>2</td><td>12.65</td><td>253</td><td>72 181 0</td></tr><tr><td>3</td><td>14.25</td><td>285</td><td>72 213 0</td></tr><tr><td>4</td><td>15.85</td><td>317</td><td>72 245 0</td></tr><tr><td>5</td><td>18.25</td><td>365</td><td>72 293 0</td></tr><tr><td>6</td><td>19.85</td><td>397</td><td>72 325 0</td></tr><tr><td>7</td><td>23.05</td><td>461</td><td>72 389 0</td></tr><tr><td>8</td><td>23.85</td><td>477</td><td>72 405 0</td></tr></tbody></table><h2 id="payload-type"><a href="#payload-type" class="headerlink" title="payload type"></a>payload type</h2><p>amrnb和amrwb使用的动态payload type, 所以在用wireshark分析时，需要经常调整payload-type值</p><h2 id="align-mode"><a href="#align-mode" class="headerlink" title="align mode"></a>align mode</h2><p>amrnb和amrwb在SIP协商中有两种align mode，对齐模式和节省带快模式。总结有几个区别</p><ul><li>对齐模式下CMR占8位，每个TOC占8位，然后每个语音帧补齐为整字节。</li><li>节省带宽模式下，CMR占4位，每个TOC占6位，然后CMR + TOC + 所有语音帧加起来，最后补齐为整字节。</li></ul><p>以单帧的12.2kbps为例</p><ul><li>语音帧为244位，对齐之后为<code>(244 + 8 - 1)/8 = 31</code>字节。加上1字节的CMR和1字节的TOC, 一共33字节。</li><li>语音帧为244位，加上4位CMR和6位TOC，一共为254位，对齐后为<code>(254 + 8-1)/8</code>，一种32字节字节。</li></ul><p>以两帧的12.2kbps为例</p><ul><li>两个语音帧分别占用31字节，加上1字节的CMR和2字节的TOC, 一共 65字节。</li><li>两个语音帧分别占用244位， 加上4位的CMR和6 * 2位的TOC, 对齐后为<code>( 488 + 4 + 12  + 8 - 1)/8</code>，一共63字节。</li></ul><p>总之，对齐模式是先对齐成字节再求和，节省带宽模式是先计算<code>位和</code>再对齐成字节。特别是多帧的时候，节省带宽模式算起来更复杂。好在实际情况都是1帧。</p><h2 id="基于opencore-amr的编解码"><a href="#基于opencore-amr的编解码" class="headerlink" title="基于opencore-amr的编解码"></a>基于opencore-amr的编解码</h2><p>开始用FFmpeg的库来做转码和推流，后来发现不支持节省带宽模式，而且还有个<a href="https://trac.ffmpeg.org/ticket/9891" target="_blank" rel="noopener">BUG</a>，所以后面自己基于opencore的库写的转码功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;最近在公司开发一个amrnb/amrwb的转码工具，在网上看了很多资料，主要是这篇&lt;a href=&quot;https://blog.csdn.ne</summary>
      
    
    
    
    
    <category term="音视频" scheme="https://energygreek.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>use mdns in systemd-networkd</title>
    <link href="https://energygreek.github.io/2022/05/23/use-mdns-in-systemd-networkd/"/>
    <id>https://energygreek.github.io/2022/05/23/use-mdns-in-systemd-networkd/</id>
    <published>2022-05-23T03:18:18.000Z</published>
    <updated>2024-02-07T09:59:29.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用systemd-resolved的mdns"><a href="#使用systemd-resolved的mdns" class="headerlink" title="使用systemd-resolved的mdns"></a>使用systemd-resolved的mdns</h1><p>之前的博客中使用了avahi来广播本机的hostname和服务，这对于打印机和其他无屏设备非常重要。而较新版本Linux发行版中systemd-networkd+systemd-resolved同样能实现此功能</p><h2 id="Network-Manager"><a href="#Network-Manager" class="headerlink" title="Network Manager"></a>Network Manager</h2><p>目前不少发行版默认的网络管理工具是NetworkManager, 需要先将其关闭和卸载，安装systemd-networkd包</p><h2 id="配置systemd-networkd"><a href="#配置systemd-networkd" class="headerlink" title="配置systemd-networkd"></a>配置systemd-networkd</h2><p>networkd 中可以配置网桥，tun等设备，也可以直接在其中配置dns和dhcp等，在其中加入MulticastDNS=yes和Multicast=yes来启用mDns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Match]</span><br><span class="line">Name&#x3D;eth0</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">Address&#x3D;192.168.4.42&#x2F;24</span><br><span class="line">DNS&#x3D;114.114.114.114</span><br><span class="line">Gataway&#x3D;192.168.4.1</span><br><span class="line">MulticastDNS&#x3D;yes</span><br><span class="line"></span><br><span class="line">[Link]</span><br><span class="line">Multicast&#x3D;yes</span><br></pre></td></tr></table></figure><h2 id="配置systemd-resolved"><a href="#配置systemd-resolved" class="headerlink" title="配置systemd-resolved"></a>配置systemd-resolved</h2><p>systemd-resolved功能类似与dnsmasq, 他会继承systemd-networkd中的dns信息，也会读取hostname用来广播，一般不用修改任何配置，之需要将其stub文件链接到/etc/resov.conf, 这样让系统的dns请求发到systemd-resolved</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ln -sf &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;stub-resolv.conf &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"># ls -l &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">lrwxrwxrwx. 1 root root 37 May 22 22:03 &#x2F;etc&#x2F;resolv.conf -&gt; &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;stub-resolv.conf</span><br></pre></td></tr></table></figure><h2 id="确认效果"><a href="#确认效果" class="headerlink" title="确认效果"></a>确认效果</h2><p>通过<code>resolvectl status</code>命令可以查看resolve配置，如下全局的MulticastDNS是启用的，而networkd中的配置是per link的，也处于启用状态，Scopes里显示了mDNS,说明其启用了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Current Scopes: DNS LLMNR&#x2F;IPv4 LLMNR&#x2F;IPv6 mDNS&#x2F;IPv4 mDNS&#x2F;IPv6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@netpanc ~]# resolvectl status</span><br><span class="line">Global</span><br><span class="line">       LLMNR setting: yes</span><br><span class="line">MulticastDNS setting: yes</span><br><span class="line">  DNSOverTLS setting: no</span><br><span class="line">      DNSSEC setting: allow-downgrade</span><br><span class="line">    DNSSEC supported: yes</span><br><span class="line">          DNSSEC NTA: 10.in-addr.arpa</span><br><span class="line">                      16.172.in-addr.arpa</span><br><span class="line">                      168.192.in-addr.arpa</span><br><span class="line">                      17.172.in-addr.arpa</span><br><span class="line">                      18.172.in-addr.arpa</span><br><span class="line">                      19.172.in-addr.arpa</span><br><span class="line">                      20.172.in-addr.arpa</span><br><span class="line">                      21.172.in-addr.arpa</span><br><span class="line">                      22.172.in-addr.arpa</span><br><span class="line">                      23.172.in-addr.arpa</span><br><span class="line">                      24.172.in-addr.arpa</span><br><span class="line">                      25.172.in-addr.arpa</span><br><span class="line">                      26.172.in-addr.arpa</span><br><span class="line">                      27.172.in-addr.arpa</span><br><span class="line">                      28.172.in-addr.arpa</span><br><span class="line">                      29.172.in-addr.arpa</span><br><span class="line">                      30.172.in-addr.arpa</span><br><span class="line">                      31.172.in-addr.arpa</span><br><span class="line">                      corp</span><br><span class="line">                      d.f.ip6.arpa</span><br><span class="line">                      home</span><br><span class="line">                      internal</span><br><span class="line">                      intranet</span><br><span class="line">                      lan</span><br><span class="line">                      local</span><br><span class="line">                      private</span><br><span class="line">                      test</span><br><span class="line"></span><br><span class="line">Link 2 (eth0)</span><br><span class="line">      Current Scopes: DNS LLMNR&#x2F;IPv4 LLMNR&#x2F;IPv6 mDNS&#x2F;IPv4 mDNS&#x2F;IPv6</span><br><span class="line">       LLMNR setting: yes</span><br><span class="line">MulticastDNS setting: yes</span><br><span class="line">  DNSOverTLS setting: no</span><br><span class="line">      DNSSEC setting: allow-downgrade</span><br><span class="line">    DNSSEC supported: yes</span><br><span class="line">  Current DNS Server: 114.114.114.114</span><br><span class="line">         DNS Servers: 114.114.114.114</span><br></pre></td></tr></table></figure><p>在其他设备上ping可以成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PING netpanc.local (192.168.4.43) 56(84) bytes of data.</span><br><span class="line">64 bytes from netpanc.local (192.168.4.43): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.350 ms</span><br><span class="line">64 bytes from netpanc.local (192.168.4.43): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.799 ms</span><br><span class="line">64 bytes from netpanc.local (192.168.4.43): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.733 ms</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wiki.archlinux.org/title/Systemd-resolved#mDNS" target="_blank" rel="noopener">https://wiki.archlinux.org/title/Systemd-resolved#mDNS</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用systemd-resolved的mdns&quot;&gt;&lt;a href=&quot;#使用systemd-resolved的mdns&quot; class=&quot;headerlink&quot; title=&quot;使用systemd-resolved的mdns&quot;&gt;&lt;/a&gt;使用systemd-resolve</summary>
      
    
    
    
    
    <category term="os-maintain" scheme="https://energygreek.github.io/tags/os-maintain/"/>
    
  </entry>
  
  <entry>
    <title>序列化和反序列化</title>
    <link href="https://energygreek.github.io/2022/05/17/serialized-and-deserialize/"/>
    <id>https://energygreek.github.io/2022/05/17/serialized-and-deserialize/</id>
    <published>2022-05-17T08:35:07.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>c/c++中，序列化是将基本类型或struct变为可存储和传递的形式，比如常用的<code>socket send</code>，将按协议组装的struct（pack)显示转换二进制（序列化）并发送给其他主机。而反序列化是将二进制转成基本类型或struct。另外还有<code>fwrite/fread</code>将结构体保存到文本中。 这种方式高效但容易出错。<br>而其他语言中可以使用xml, json等高级方式</p><h2 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h2><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>上面讲到的两个函数send和fwrite,都是将基本类型或struct类型强转为字符串, 这种可能受不同机器的对齐影响</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb,</span></span></span><br><span class="line"><span class="function"><span class="params">    FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>序列化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">  buf.a = <span class="number">1</span>;</span><br><span class="line">  buf.b = <span class="string">'a'</span>;</span><br><span class="line">  buf.c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  FILE *f = fopen(<span class="string">"/tmp/buf"</span>, <span class="string">"w+"</span>);</span><br><span class="line">  <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fwrite(&amp;buf, <span class="keyword">sizeof</span>(struct <span class="built_in">buffer</span>), <span class="number">1</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">  FILE *f = fopen(<span class="string">"/tmp/buf"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fread(&amp;buf, <span class="keyword">sizeof</span>(struct <span class="built_in">buffer</span>), <span class="number">1</span>, f);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d--%c--%lf--\n"</span>, buf.a, buf.b, buf.c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package serialize;</span><br><span class="line"></span><br><span class="line">option optimize_for &#x3D; LITE_RUNTIME;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">string name &#x3D; 1;</span><br><span class="line">int32 id &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tutorial::Person <span class="title">Serialize</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> email)</span></span>&#123;</span><br><span class="line">    tutorial::Person person;</span><br><span class="line">    person.set_name(name);</span><br><span class="line">    person.set_id(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(tutorial::Person person)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; person.SerializeAsString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="optimize-for-option"><a href="#optimize-for-option" class="headerlink" title="optimize_for option"></a>optimize_for option</h3><p>optimize_for (file option): Can be set to SPEED, CODE_SIZE, or LITE_RUNTIME. This affects the C++ and Java code generators (and possibly third-party generators) in the following ways:</p><ul><li>SPEED (default): The protocol buffer compiler will generate code for serializing, parsing, and performing other common operations on your message types. This code is highly optimized.</li><li>CODE_SIZE: The protocol buffer compiler will generate minimal classes and will rely on shared, reflection-based code to implement serialialization, parsing, and various other operations. The generated code will thus be much smaller than with SPEED, but operations will be slower. Classes will still implement exactly the same public API as they do in SPEED mode. This mode is most useful in apps that contain a very large number of .proto files and do not need all of them to be blindingly fast.</li><li>LITE_RUNTIME: The protocol buffer compiler will generate classes that depend only on the “lite” runtime library (libprotobuf-lite instead of libprotobuf). The lite runtime is much smaller than the full library (around an order of magnitude smaller) but omits certain features like descriptors and reflection. This is particularly useful for apps running on constrained platforms like mobile phones. The compiler will still generate fast implementations of all methods as it does in SPEED mode. Generated classes will only implement the MessageLite interface in each language, which provides only a subset of the methods of the full Message interface.</li></ul><h2 id="其他还有如xml-json-ninja"><a href="#其他还有如xml-json-ninja" class="headerlink" title="其他还有如xml, json, ninja"></a>其他还有如xml, json, ninja</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;c/c++中，序列化是将基本类型或struct变为可存储和传递的形式，比如常用的&lt;code&gt;socket send&lt;/code&gt;，将按协议组</summary>
      
    
    
    
    
    <category term="seralize" scheme="https://energygreek.github.io/tags/seralize/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://energygreek.github.io/2022/05/12/package-problem/"/>
    <id>https://energygreek.github.io/2022/05/12/package-problem/</id>
    <published>2022-05-12T05:25:01.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>有一个承重为V的背包，有N个物品，重量分别为Cost[i], 价值分别为Value[i], 问选择放哪些物品时包的价值最大</p><h2 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h2><p>解决动态编程的关键是找到状态方程，如下。 解决背包问题就是比较<code>放</code>与<code>不放</code>哪个价值高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F [i, v] ← max&#123;F [i − 1, v], F [i − 1, v − Ci] + Wi&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>要求物品最大为1个, 这里有几个版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">4</span>, N = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cost[N] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value[N] = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const int V = 10, N = 5;</span></span><br><span class="line"><span class="comment">// const int cost[N] = &#123;2, 3, 5, 2, 4&#125;;</span></span><br><span class="line"><span class="comment">// const int value[N] = &#123;2, 2, 1, 1, 2&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">O1Package_N</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dp[N][V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0容量的价值为0, 合法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化当包承重大于物品0重量的情况</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = cost[<span class="number">0</span>]; j &lt;= V; j++) &#123;</span><br><span class="line">    <span class="comment">// 当只装物品0时，包的价值就是物品0的价值</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++) &#123;</span><br><span class="line">      <span class="comment">// F [i, v] ← max&#123;F [i − 1, v], F [i − 1, v − Ci] + Wi&#125;</span></span><br><span class="line">      <span class="comment">// F[i][v] = MAX(F[i - 1][v], F[i - 1][v - cost[i]] + value[i]);</span></span><br><span class="line">      <span class="keyword">int</span> bufang = dp[i - <span class="number">1</span>][v];</span><br><span class="line">      dp[i][v] = bufang;</span><br><span class="line">      <span class="keyword">if</span> (v &gt;= cost[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> fang = dp[i - <span class="number">1</span>][v - cost[i]] + value[i];</span><br><span class="line">        dp[i][v] = MAX(bufang, fang);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N - <span class="number">1</span>][V]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">O1Package_N_plus_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dp[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用0个物品的价值为0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++) &#123;</span><br><span class="line">      dp[i][v] = dp[i - <span class="number">1</span>][v]; <span class="comment">//当重量不够装i时，价值为装i-1的价值,</span></span><br><span class="line">                               <span class="comment">//此步骤以备i+1时使用（下一个i循环）</span></span><br><span class="line">      <span class="keyword">if</span> (v &gt;= cost[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][v] = MAX(dp[i - <span class="number">1</span>][v], dp[i - <span class="number">1</span>][v - cost[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N][V]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">O1Package_N_plus_1_origin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dp[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用0个物品的价值为0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++) &#123;</span><br><span class="line">      <span class="comment">// 1. 当物品大于承重，物品不会放到背包，价值等于不放此物品时的情况</span></span><br><span class="line">      <span class="comment">// 即使物品小于承重，说明物品会放到背包。提前多赋值一次也是允许的</span></span><br><span class="line">      dp[i + <span class="number">1</span>][v] = dp[i][v];</span><br><span class="line">      <span class="keyword">if</span> (v &gt;= cost[i]) &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>][v] = MAX(dp[i][v], dp[i][v - cost[i]] + value[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N][V]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">O1Package_one_array_n</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dp[V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用0个物品的价值为0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &gt;= cost[i]; v--) &#123;</span><br><span class="line">      <span class="keyword">int</span> bufang = dp[v];</span><br><span class="line">      <span class="keyword">int</span> fang = dp[v - cost[i]] + value[i];</span><br><span class="line">      dp[v] = MAX(bufang, fang);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>要求物品可以取无限个，但由于包的承重为V,所以每种物品最大数量为 V/cost[i]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePackage_use_n</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dp[N][V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0容量的价值为0, 合法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cost[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化当包承重大于物品0重量的情况</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = cost[<span class="number">0</span>]; i &lt;= V; i++) &#123;</span><br><span class="line">    <span class="comment">// 当只装物品0时，包的价值就是物品0的价值</span></span><br><span class="line">    dp[<span class="number">0</span>][i] = i / cost[<span class="number">0</span>] * value[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++) &#123;</span><br><span class="line">      dp[i][v] = dp[i - <span class="number">1</span>][v]; <span class="comment">//当重量不够装i时，价值为装i-1的价值,</span></span><br><span class="line">                               <span class="comment">//此步骤以备i+1时使用（下一个i循环）</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= v / cost[i]; k++) &#123;</span><br><span class="line">        dp[i][v] = MAX(dp[i - <span class="number">1</span>][v], dp[i - <span class="number">1</span>][v - k * cost[i]] + k * value[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N - <span class="number">1</span>][V]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePackage_use_n_plus_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dp[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0容量的价值为0, 合法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++) &#123;</span><br><span class="line">      dp[i][v] = dp[i - <span class="number">1</span>][v]; <span class="comment">//当重量不够装i时，价值为装i-1的价值,</span></span><br><span class="line">                               <span class="comment">//此步骤以备i+1时使用（下一个i循环）</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= v / cost[i<span class="number">-1</span>]; k++) &#123;</span><br><span class="line">        dp[i][v] = MAX(dp[i - <span class="number">1</span>][v], dp[i - <span class="number">1</span>][v - k * cost[i<span class="number">-1</span>]] + k * value[i<span class="number">-1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N][V]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePackage_use_one_array_no_reverse_V</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dp[V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0容量的价值为0, 合法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= v / cost[i<span class="number">-1</span>]; k++) &#123;</span><br><span class="line">        dp[v] = MAX(dp[v], dp[v - k * cost[i<span class="number">-1</span>]] + k * value[i<span class="number">-1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePackage_use_one_array_reverse_V</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dp[V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0容量的价值为0, 合法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先遍历物品，后遍历重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &lt;= cost[i<span class="number">-1</span>]; v--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= v / cost[i<span class="number">-1</span>]; k++) &#123;</span><br><span class="line">        dp[v] = MAX(dp[v], dp[v - k * cost[i<span class="number">-1</span>]] + k * value[i<span class="number">-1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, dp[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包规定了每个物品的最大数量cap[i], 但由于要考虑背包承重，所以真正可以容纳物品的最大个数是max（cap[i], V/cost[i])</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="为何不需要将背包排序，-比如按重量排序或按价值排序，再将重量下而价值高的物品优先计算？"><a href="#为何不需要将背包排序，-比如按重量排序或按价值排序，再将重量下而价值高的物品优先计算？" class="headerlink" title="为何不需要将背包排序， 比如按重量排序或按价值排序，再将重量下而价值高的物品优先计算？"></a>为何不需要将背包排序， 比如按重量排序或按价值排序，再将重量下而价值高的物品优先计算？</h3><p>即使没有排序，由于第二层循环都是从<code>0-&gt;V</code>遍历和放物品i与不放物品i比较，所以顺序不重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++) &#123;</span><br><span class="line">    <span class="keyword">int</span> bufang = dp[i - <span class="number">1</span>][v];</span><br><span class="line">    dp[i][v] = bufang;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= cost[i]) &#123;</span><br><span class="line">      <span class="keyword">int</span> fang = dp[i - <span class="number">1</span>][v - cost[i]] + value[i];</span><br><span class="line">      dp[i][v] = MAX(bufang, fang);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度和优化"><a href="#算法复杂度和优化" class="headerlink" title="算法复杂度和优化"></a>算法复杂度和优化</h3><p>矩阵数组的时间复杂度为O(V<em>N),即两层for循环；空间复杂度为O(V</em>N) 即申请一个矩形数组，经过一元数组优化后，空间复杂度变为O(V)<br>除此之外，<br>大多情况下，通过两层遍历，可以只保留重量相同且价值最大的那个物品，这个操作的时间复杂度为O(N^2), 但当最糟糕的情况，即精心设计的物品没有相同重量或者相同价值的情况则此优化无效<br>另外，先加物品重量大于背包重量的物品忽略，可以加快速度</p><h3 id="理解优化"><a href="#理解优化" class="headerlink" title="理解优化"></a>理解优化</h3><p>无论是用矩阵数组还是优化成一元数组，最好的理解方式是单步调试一遍</p><h3 id="N行与N-1行"><a href="#N行与N-1行" class="headerlink" title="N行与N+1行"></a>N行与N+1行</h3><p>两种方式可以通用，只是当N行时，需要提前初始化物品0的情况</p><h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p><p>如果是第一种问法，要求恰好装满背包，那么在初始化时除了 F[0] 为 0，其它F[1..V ] 均设为 −∞，这样就可以保证最终得到的 F[V ] 是一种恰好装满背包的最优解。<br>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F[0..V ]全部设为 0。</p><p>这是为什么呢？可以这样理解：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0了。</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>由于背包问题里的物品具备<strong>重量</strong>和<strong>价值</strong>两个维度，所以无法用贪心算法解决。而当维度为1的时候，可以用贪心算法，例如<del>零钱问题</del>和会议安排问题，因为不同零钱价值不同但其“重量”都为1，会议的“重量”也为1<br><strong>注</strong>: leetcode上的<a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">零钱问题</a>不能用贪心算法</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《背包问题九讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背包问题&quot;&gt;&lt;a href=&quot;#背包问题&quot; class=&quot;headerlink&quot; title=&quot;背包问题&quot;&gt;&lt;/a&gt;背包问题&lt;/h1&gt;&lt;p&gt;有一个承重为V的背包，有N个物品，重量分别为Cost[i], 价值分别为Value[i], 问选择放哪些物品时包的价值最大&lt;</summary>
      
    
    
    
    
    <category term="algorithm" scheme="https://energygreek.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>记一个FakeIt使用问题</title>
    <link href="https://energygreek.github.io/2022/05/05/a-FakeIt-issue/"/>
    <id>https://energygreek.github.io/2022/05/05/a-FakeIt-issue/</id>
    <published>2022-05-05T10:25:40.000Z</published>
    <updated>2024-02-07T09:59:29.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FakeIt"><a href="#FakeIt" class="headerlink" title="FakeIt"></a>FakeIt</h1><p>FakeIt是一个单元测试工具，类比gmock, 但是比gmock更modern和轻量，因为它支持c++11和header-only</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>FakeIt和gmock都提供Mock和调用计数功能，Mock通常用于接口类，用来定义并实例化接口类对象。gmock和FakeIt都能对调用参数进行校验，但FakeIt的Verify函数还提供在校验失败时打印参数值，这是gmock不具备的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct IAppManager &#123;</span><br><span class="line">  &#x2F;&#x2F; inotify calls when new event</span><br><span class="line">  virtual void notify_add_event(EventType event_type,</span><br><span class="line">                                const std::string&amp; filepath) &#x3D; 0;</span><br><span class="line">  virtual void notify_rename_event(EventType event_type,</span><br><span class="line">                                   const std::string&amp; filepath,</span><br><span class="line">                                   const std::string&amp; filepath_new) &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  virtual ~IAppManager() &#x3D; default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_CASE(&quot;Test Inotify&quot;) &#123;</span><br><span class="line">  Mock&lt;IAppManager&gt; appmanager_mock;</span><br><span class="line">  Fake(Dtor(appmanager_mock));</span><br><span class="line">  Fake(Method(appmanager_mock, notify_add_event));</span><br><span class="line">  Fake(Method(appmanager_mock, notify_rename_event));</span><br><span class="line"></span><br><span class="line">  auto&amp; app_manager &#x3D; appmanager_mock.get();</span><br><span class="line">  SECTION(&quot;test add&quot;) &#123;</span><br><span class="line">    std::thread t1([&amp;app_manager]()&#123;</span><br><span class="line">      app_manager.notify_add_event(EventType::File, &quot;filename&quot;);</span><br><span class="line">      app_manager.notify_add_event(EventType::File, &quot;filename&quot;);</span><br><span class="line">      app_manager.notify_add_event(EventType::File, &quot;filename&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.join();</span><br><span class="line">    Verify(Method(appmanager_mock, notify_add_event)).Exactly(2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有对调用参数校验，而仅对调用次数验证，可以预见，结果失败，因为调用了3次。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>上面的测试用例会失败，因为次数不匹配。而这时FakeIt会打印所有调用的参数值，但参数由于是个引用，而且引用在线程退出时被释放，打印一个无效引用导致会抛异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">due to a fatal error condition:                                                                 </span><br><span class="line">  SIGSEGV - Segmentation violation signal</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>对于本测试而言，解决办法就是将传参所引用的对象duration改大，如全局变量或者static，或者在线程外定义它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEST_CASE(&quot;Test Inotify&quot;) &#123;</span><br><span class="line">  Mock&lt;IAppManager&gt; appmanager_mock;</span><br><span class="line">  Fake(Dtor(appmanager_mock));</span><br><span class="line">  Fake(Method(appmanager_mock, notify_add_event));</span><br><span class="line">  Fake(Method(appmanager_mock, notify_rename_event));</span><br><span class="line"></span><br><span class="line">  auto&amp; app_manager &#x3D; appmanager_mock.get();</span><br><span class="line">  SECTION(&quot;test add&quot;) &#123;</span><br><span class="line">    std::string filename &#x3D; &quot;asd&quot;;</span><br><span class="line">    std::thread t1([&amp;app_manager, &amp;filename]()&#123;</span><br><span class="line">      app_manager.notify_add_event(EventType::File, filename);</span><br><span class="line">      app_manager.notify_add_event(EventType::File, filename);</span><br><span class="line">      app_manager.notify_add_event(EventType::File, filename);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.join();</span><br><span class="line">    Verify(Method(appmanager_mock, notify_add_event)).Exactly(2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后，不会触发SIGSEGV异常, 而是能正确打印出调用参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Expected pattern: appmanager_mock.notify_add_event( Any arguments )</span><br><span class="line">Expected matches: exactly 2</span><br><span class="line">Actual matches  : 3</span><br><span class="line">Actual sequence : total of 3 actual invocations:                             </span><br><span class="line">  appmanager_mock.notify_add_event(?, asd)</span><br><span class="line">  appmanager_mock.notify_add_event(?, asd)</span><br><span class="line">  appmanager_mock.notify_add_event(?, asd)</span><br></pre></td></tr></table></figure><p>但对于间接调用的接口，且在单元测试里无法控制变量类型，则没有什么办法，只能保证Extractly准确而不用打印参数值</p><h2 id="gmock的方式"><a href="#gmock的方式" class="headerlink" title="gmock的方式"></a>gmock的方式</h2><p>gmock使用预先设定调用参数，在调用时再判断，所以不会出现无效引用的问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FakeIt&quot;&gt;&lt;a href=&quot;#FakeIt&quot; class=&quot;headerlink&quot; title=&quot;FakeIt&quot;&gt;&lt;/a&gt;FakeIt&lt;/h1&gt;&lt;p&gt;FakeIt是一个单元测试工具，类比gmock, 但是比gmock更modern和轻量，因为它支持c++11</summary>
      
    
    
    
    
    <category term="unit test" scheme="https://energygreek.github.io/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>单向链表翻转算法</title>
    <link href="https://energygreek.github.io/2022/04/21/rotate-list/"/>
    <id>https://energygreek.github.io/2022/04/21/rotate-list/</id>
    <published>2022-04-21T05:44:10.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三指针法翻转单向链表"><a href="#三指针法翻转单向链表" class="headerlink" title="三指针法翻转单向链表"></a>三指针法翻转单向链表</h1><p>定义3个指针, 原理是三个指针分别指向前三个元素，将第一个元素指向第二个元素，然后全部后移</p><ol><li>第三个指针向前移动</li><li>将第二个元素指向第一个元素</li><li>第一个指针和第二个指针向前移动</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> data;</span><br><span class="line">　　Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">reverse</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">  Node *pPrev = <span class="literal">nullptr</span>;</span><br><span class="line">  Node *pHead = head;</span><br><span class="line">  Node *pNext = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (pHead) &#123;</span><br><span class="line">    pNext = pHead-&gt;next;</span><br><span class="line">    pHead-&gt;next = pPrev;</span><br><span class="line">    pPrev = pHead;</span><br><span class="line">    pHead = pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">reverse</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  Node *first = <span class="literal">nullptr</span>;</span><br><span class="line">  Node *second = head;</span><br><span class="line">  Node *third = head-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (third) &#123;</span><br><span class="line">    second-&gt;next = first;</span><br><span class="line"></span><br><span class="line">    first = second;</span><br><span class="line">    second = third;</span><br><span class="line">    third = third-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  second-&gt;next = first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转链表的部分节点"><a href="#翻转链表的部分节点" class="headerlink" title="翻转链表的部分节点"></a>翻转链表的部分节点</h2><p>翻转node[m]-&gt;node[N]部分， 理解时先将链表分为3部分: part1-&gt;part2-&gt;part3, 只翻转part2  </p><p>翻转动作套用三指针法，但部分翻转的难点在于处理part1为空和非空的情况，所以要判断m时候为1</p><ul><li>m==1即要翻转第一个元素时，需要先记录part2翻转后的tail node，最后将其next指向part3的第一个元素</li><li>m!=1即part1不为空，需要先记录part2翻转后的tail node和part1的最后一个node，最后将其指向part2的新head,以及将part2的第一个node指向part3</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverseBetween</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!head || !head-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pleft</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">phead</span> = <span class="title">head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pright</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有当m！=1时才需要，指向part1的最后一个元素</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pPart1Tail</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="comment">// 当m=1时指向part2的第一个元素</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pPart2NewTail</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// skip m</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    pleft = phead; </span><br><span class="line">    phead = phead-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存part2的head,也是翻转后的tail</span></span><br><span class="line">  pPart2NewTail = phead;</span><br><span class="line">  <span class="comment">// m != 1 时pleft不为NULL</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pPartOneTail</span> = <span class="title">pleft</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 翻转次数要比m-n大1</span></span><br><span class="line">  <span class="keyword">while</span> (phead &amp;&amp; i &lt; n - m + <span class="number">1</span>) &#123;</span><br><span class="line">    pright = phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    phead-&gt;next = pleft;</span><br><span class="line"></span><br><span class="line">    pleft = phead;</span><br><span class="line">    phead = pright;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 指向part3的头</span></span><br><span class="line">    pPart2NewTail-&gt;next = phead;</span><br><span class="line">    <span class="keyword">return</span> pleft;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pPartOneTail-&gt;next = pleft;</span><br><span class="line">  pPart2NewTail-&gt;next = phead;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三指针法翻转单向链表&quot;&gt;&lt;a href=&quot;#三指针法翻转单向链表&quot; class=&quot;headerlink&quot; title=&quot;三指针法翻转单向链表&quot;&gt;&lt;/a&gt;三指针法翻转单向链表&lt;/h1&gt;&lt;p&gt;定义3个指针, 原理是三个指针分别指向前三个元素，将第一个元素指向第二个元素</summary>
      
    
    
    
    
    <category term="algorithm" scheme="https://energygreek.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>sdcc compiler for 51</title>
    <link href="https://energygreek.github.io/2022/04/10/sdcc-compile-for-51/"/>
    <id>https://energygreek.github.io/2022/04/10/sdcc-compile-for-51/</id>
    <published>2022-04-10T01:25:49.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Linux下使用sdcc进行单片机开发"><a href="#在Linux下使用sdcc进行单片机开发" class="headerlink" title="在Linux下使用sdcc进行单片机开发"></a>在Linux下使用sdcc进行单片机开发</h1><p>周末研究了下单片机，本来准备写个定时器来控制电扇开关，发现比起树梅派，单片机实在不太方便</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>Windows大家都用Keil, 一站式比较方便，但这是个收费软件。而在Linux下，使用到一些组合来实现编译和烧录</p><ol><li>sdcc 开源的编译器，类似gcc</li><li><a href="https://github.com/laborer/stcflash" target="_blank" rel="noopener">stcflash</a> github上的开发者开发的烧录脚本</li></ol><p>sdcc 在Debian有包可以直接安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># apt install sdcc</span><br></pre></td></tr></table></figure><p>再 clone github的代码到本地，需要使用root权限执行烧录。而我执行是发现缺少python serial包，要全局安装就使用apt命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># apt install python3-serial</span><br></pre></td></tr></table></figure><p>这样环境就搭建好了</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>用c语言开发时要引入比较的定义头文件，我的单片机是好多年前买的国产<code>stc 89C52RC</code>， 是基于51的拓展版本，于是用了sdcc的<code>8052.h</code>头，路径在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/share/sdcc/include/mcs51/8052.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> REG8052_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG8052_H</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;8051.h&gt;     /* load definitions for the 8051 core */</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REG8051_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> REG8051_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>不过不需要我们指定路径，sdcc会自动引入。窥视其内容可以发现它包含了8051的东西，所以说52是基于51的</p><h2 id="回顾一下51单片机知识"><a href="#回顾一下51单片机知识" class="headerlink" title="回顾一下51单片机知识"></a>回顾一下51单片机知识</h2><ol><li>单片机的寄存器初始是0, 而引脚初始都是高点位</li><li>定时器和计数器的触发事件都是靠中断，中断执行当前（main）中的函数而执行中断响应函数，这跟Unix内核是一样的。 单片机还具有多个优先级的中断，可以嵌套</li><li>中断的触发靠计数寄存器（TLx和THx）溢出，这两个都是8位寄存器，所以同时使用时，在2^16时溢出。但也有只用其中一个寄存器的时候，这由<code>TMOD</code>寄存器控制</li></ol><h3 id="TMOD寄存器"><a href="#TMOD寄存器" class="headerlink" title="TMOD寄存器"></a>TMOD寄存器</h3><p>TMOD是不可按位访问的寄存器，意思是只能一次性赋值所有位。 TMOD控制着两个定时器/计数器0和1</p><p><img src="/images/timer.png" alt="timer"></p><ul><li>TMOD高四位用于设置定时器/计数器1，低四位用于设置定时器/计数器0；</li><li>GATE寄存器决定是否使用外部INTx控制，即软件自动启动，还是外部启动，这里赋值0<ul><li>GATE=1时，“与门”的输出信号K由INTx输入电平和TRx位的状态一起决定(即此时K=TRx·INTx)，当且仅当TRx=1,INTx=1(高电平)时，计数启动；否则，计数停止。当INT0引脚为高平时且TR0置位，TR0=1；启动定时器T0</li><li>GATE=0时，“A”输出恒为1，“B”的值由TRx决定，当TR0=1,启动定时器/计数器T0，当TR1=1，启动定时器/计数器T1</li></ul></li><li>CT位为1时选择计数器模式，为0时选择定时器模式</li><li>M1,M0用于选择工作方式，当M0=1,M1=0时，使用TL0和TH0的16位来计数</li></ul><h3 id="TCON寄存器"><a href="#TCON寄存器" class="headerlink" title="TCON寄存器"></a>TCON寄存器</h3><p><img src="/images/TCON.png" alt="TCON"></p><h3 id="定时器初始化"><a href="#定时器初始化" class="headerlink" title="定时器初始化"></a>定时器初始化</h3><p>这里使用定时器0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Timer0Init(void) &#x2F;&#x2F; 1毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">    TMOD &#x3D; 0x01; &#x2F;&#x2F;设置定时器模式 0000 0001</span><br><span class="line">    &#x2F;&#x2F; TCON</span><br><span class="line">    TF0 &#x3D; 0; &#x2F;&#x2F;初始化溢出标志</span><br><span class="line">    TR0 &#x3D; 1; &#x2F;&#x2F;定时器0开始计时</span><br><span class="line">    &#x2F;&#x2F; 计数器初始值，再触发一次就溢出了</span><br><span class="line">    TH0 &#x3D; 0xFF; &#x2F;&#x2F;设置定时初值</span><br><span class="line">    TL0 &#x3D; 0xFE; &#x2F;&#x2F;设置定时初值</span><br><span class="line">    &#x2F;&#x2F; 中断通路</span><br><span class="line">    EA &#x3D; 1; </span><br><span class="line">    ET0 &#x3D; 1;</span><br><span class="line">    PT0 &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数器模式"><a href="#计数器模式" class="headerlink" title="计数器模式"></a>计数器模式</h3><p>这里使用计数器0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Count0Init</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">// 1毫秒@12.000MHz</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TMOD = <span class="number">0x05</span>; <span class="comment">//设置计数器模式 0000 0101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCON</span></span><br><span class="line">    TF0 = <span class="number">0</span>; </span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">//定时器0开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器初始值，再触发一次就溢出了</span></span><br><span class="line">    TH0 = <span class="number">0xFF</span>;  <span class="comment">//设置定时初值</span></span><br><span class="line">    TL0 = <span class="number">0xFE</span>;  <span class="comment">//设置定时初值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断通路</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    PT0 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中断响应函数"><a href="#中断响应函数" class="headerlink" title="中断响应函数"></a>中断响应函数</h3><p>sdcc和keil有一些区别，中断标志符使用<code>__interrupt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> T0Count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0_routine</span><span class="params">()</span> __<span class="title">interrupt</span> <span class="params">(<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  T0Count++;</span><br><span class="line">  TH0 = <span class="number">0xFF</span>; <span class="comment">//设置定时初值</span></span><br><span class="line">  TL0 = <span class="number">0xFE</span>; <span class="comment">//设置定时初值</span></span><br><span class="line">  <span class="keyword">if</span> (T0Count == <span class="number">3</span>) &#123;</span><br><span class="line">    T0Count = <span class="number">0</span>;</span><br><span class="line">    P1_1 = <span class="number">0</span>;  <span class="comment">// 0输出低电平，灯泡亮</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"8052.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">// 1毫秒@12.000MHz</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TMOD = <span class="number">0x01</span>;</span><br><span class="line">  TF0 = <span class="number">0</span>;</span><br><span class="line">  TR0 = <span class="number">1</span>;</span><br><span class="line">  TH0 = <span class="number">0xFF</span>;</span><br><span class="line">  TL0 = <span class="number">0xFE</span>;</span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">  ET0 = <span class="number">1</span>;</span><br><span class="line">  PT0 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Timer1Init();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> T0Count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0_routine</span><span class="params">()</span> __<span class="title">interrupt</span><span class="params">(<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  T0Count++;</span><br><span class="line">  TH0 = <span class="number">0xFF</span>;</span><br><span class="line">  TL0 = <span class="number">0xFE</span>;</span><br><span class="line">  <span class="keyword">if</span> (T0Count == <span class="number">3</span>) &#123;</span><br><span class="line">    T0Count = <span class="number">0</span>;</span><br><span class="line">    P1_1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译和烧录"><a href="#编译和烧录" class="headerlink" title="编译和烧录"></a>编译和烧录</h2><p>代码保存为main.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用sdcc编译</span><br><span class="line">sdcc main.c</span><br><span class="line">将sdcc生成的ihx文件转为hex文件</span><br><span class="line">packihx main.ihx  &gt; main.hex</span><br></pre></td></tr></table></figure><p>烧录到单片机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo python ~/github/stcflash/stcflash.py main.hex</span><br><span class="line">Connect to /dev/ttyUSB0 at baudrate 2400</span><br><span class="line">Detecting target... <span class="keyword">done</span></span><br><span class="line"> FOSC: 11.955MHz</span><br><span class="line"> Model: STC89C52RC (ver4.3C) </span><br><span class="line"> ROM: 8KB</span><br><span class="line"> [X] Reset stops watchdog</span><br><span class="line"> [X] Internal XRAM</span><br><span class="line"> [X] Normal ALE pin</span><br><span class="line"> [X] Full gain oscillator</span><br><span class="line"> [X] Not erase data EEPROM</span><br><span class="line"> [X] Download regardless of P1</span><br><span class="line"> [X] 12T mode</span><br><span class="line">Baudrate: 38400</span><br><span class="line">Erasing target... <span class="keyword">done</span></span><br><span class="line">Size of the binary: 147</span><br><span class="line">Programming: <span class="comment">#################### done</span></span><br><span class="line">Setting options... <span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Linux下使用sdcc进行单片机开发&quot;&gt;&lt;a href=&quot;#在Linux下使用sdcc进行单片机开发&quot; class=&quot;headerlink&quot; title=&quot;在Linux下使用sdcc进行单片机开发&quot;&gt;&lt;/a&gt;在Linux下使用sdcc进行单片机开发&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="51单片机" scheme="https://energygreek.github.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>sql learning</title>
    <link href="https://energygreek.github.io/2022/03/21/sql-learning/"/>
    <id>https://energygreek.github.io/2022/03/21/sql-learning/</id>
    <published>2022-03-21T08:29:09.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库优化总结"><a href="#数据库优化总结" class="headerlink" title="数据库优化总结"></a>数据库优化总结</h1><p>这里总结了从数据库设计和sql结构两个方面的优化</p><h2 id="数据库设计范式-Normal-Form"><a href="#数据库设计范式-Normal-Form" class="headerlink" title="数据库设计范式 Normal Form"></a>数据库设计范式 Normal Form</h2><p>范式是在数据库的设计时总结出来的一套规范，通常满足3范式就足够了。但由于3范式也存在问题，所以有了3.5范式</p><p>范式从1到3是越来越严格，所以满足1NF不一定满足2NF，但满足2NF就肯定满足1NF    </p><p>满足所有范式的表没有冗余数据，但也有问题，比如效率不高。这就有了反范式做法，即允许数据冗余，用空间换时间</p><h3 id="1NF：原子化，单元格里的值不能被分割"><a href="#1NF：原子化，单元格里的值不能被分割" class="headerlink" title="1NF：原子化，单元格里的值不能被分割"></a>1NF：原子化，单元格里的值不能被分割</h3><table><thead><tr><th>Employee Id</th><th>Employee Name</th><th>Phone Number</th><th>Salary</th></tr></thead><tbody><tr><td>1EDU001</td><td>Alex</td><td>+91 85532065 <br> +91 85532066</td><td>60,131</td></tr><tr><td>1EDU002</td><td>Alex</td><td>+91 85532066</td><td>75,331</td></tr><tr><td>1EDU003</td><td>Alex</td><td>+91 85532068</td><td>63,231</td></tr><tr><td>1EDU004</td><td>Alex</td><td>+91 85532069</td><td>70,231</td></tr><tr><td>1EDU005</td><td>Alex</td><td>+91 85543065 <br> +91 85543075</td><td>60,531</td></tr></tbody></table><p>可见，有条目的电话格里有两个号码，是可以分割的， 所以不满足1NF。应改为</p><table><thead><tr><th>Employee Id</th><th>Employee Name</th><th>Phone Number</th><th>Salary</th></tr></thead><tbody><tr><td>1EDU001</td><td>Alex</td><td>+91 85532065</td><td>60,131</td></tr><tr><td>1EDU001</td><td>Alex</td><td>+91 85532066</td><td>60,131</td></tr><tr><td>1EDU002</td><td>Alex</td><td>+91 85532066</td><td>75,331</td></tr><tr><td>1EDU003</td><td>Alex</td><td>+91 85532068</td><td>63,231</td></tr><tr><td>1EDU004</td><td>Alex</td><td>+91 85532069</td><td>70,231</td></tr><tr><td>1EDU005</td><td>Alex</td><td>+91 85543065</td><td>60,531</td></tr><tr><td>1EDU005</td><td>Alex</td><td>+91 85543075</td><td>60,531</td></tr></tbody></table><p>当所有单元格都无法分割了，就满足了第一范式</p><h3 id="2NF：属性不允许部分依赖（复合）主键"><a href="#2NF：属性不允许部分依赖（复合）主键" class="headerlink" title="2NF：属性不允许部分依赖（复合）主键"></a>2NF：属性不允许部分依赖（复合）主键</h3><p>满足2NF前提要满足1NF, 范式2要求非主属性必须依赖完整复合主键或者主键。  </p><p>下表<code>Employee Id</code>和<code>Department Id</code>组成复合主键<br>|Employee Id|Department Id |Office Location |<br>|—|—|—|<br>|1EDUO01 | ED-T1 | Pune |<br>|1EDUO02 | ED-S2 |Bengaluru |<br>|1EDUO03 | ED-M1 | Delhi |<br>|1EDUO04 | ED-T3 | Mumbai |<br>|1EDUO05 | ED-T1 | Pune |</p><p>但<code>Office Location</code>只依赖主键的<code>Employee Id</code>部分。或者说只需<code>Department Id</code>就能保证<code>Office Location</code>唯一， 所以是部分依赖。这样不满足2NF了，应改成两个表</p><table><thead><tr><th>Employee Id</th><th>Department Id</th></tr></thead><tbody><tr><td>1EDUO01</td><td>ED-T1</td></tr><tr><td>1EDUO02</td><td>ED-S2</td></tr><tr><td>1EDUO03</td><td>ED-M1</td></tr><tr><td>1EDUO04</td><td>ED-T3</td></tr><tr><td>1EDUO05</td><td>ED-T1</td></tr></tbody></table><table><thead><tr><th>Department Id</th><th>Office Location</th></tr></thead><tbody><tr><td>ED-T1</td><td>Pune</td></tr><tr><td>ED-S2</td><td>Bengaluru</td></tr><tr><td>ED-M1</td><td>Delhi</td></tr><tr><td>ED-T3</td><td>Mumbai</td></tr></tbody></table><h3 id="3NF：-依赖不能传递"><a href="#3NF：-依赖不能传递" class="headerlink" title="3NF： 依赖不能传递"></a>3NF： 依赖不能传递</h3><p>满足3NF前提要满足2NF, 还有非主属性必须依赖主键/复合主键，不能依赖其他非主属性</p><table><thead><tr><th>Student Id</th><th>Student name</th><th>Subject Id</th><th>Subject</th><th>Adress</th></tr></thead><tbody><tr><td>1DT1SENGO1</td><td>Alex</td><td>15CS11</td><td>SQL</td><td>Goa</td></tr><tr><td>1DT1SENGO2</td><td>Barry</td><td>15CS13</td><td>JAVA</td><td>Bengaluru</td></tr><tr><td>1DT15ENGO3</td><td>Clair</td><td>15CS12</td><td>C++</td><td>Delhi</td></tr><tr><td>1DT15ENG04</td><td>DavId</td><td>15CS13</td><td>JAVA</td><td>Kochi</td></tr></tbody></table><p>上表的<code>Subject</code>依赖非主属性<code>Subject Id</code>，而不是依赖<code>Student Id</code>， 这就不满足3NF了。应改成</p><table><thead><tr><th>Student Id</th><th>Student name</th><th>Subject Id</th></tr></thead><tbody><tr><td>1DT1SENGO1</td><td>Alex</td><td>15CS11</td></tr><tr><td>1DT1SENGO2</td><td>Barry</td><td>15CS13</td></tr><tr><td>1DT15ENGO3</td><td>Clair</td><td>15CS12</td></tr><tr><td>1DT15ENG04</td><td>DavId</td><td>15CS13</td></tr></tbody></table><table><thead><tr><th>Subject Id</th><th>Subject</th><th>Adress</th></tr></thead><tbody><tr><td>15CS11</td><td>SQL</td><td>Goa</td></tr><tr><td>15CS13</td><td>JAVA</td><td>Bengaluru</td></tr><tr><td>15CS12</td><td>C++</td><td>Delhi</td></tr><tr><td>15CS13</td><td>JAVA</td><td>Kochi</td></tr></tbody></table><h4 id="不满足3范式的问题"><a href="#不满足3范式的问题" class="headerlink" title="不满足3范式的问题"></a>不满足3范式的问题</h4><p>不满足3范式的数据库会存在以下问题:</p><ul><li>插入问题： 插入数据时，如果只有部分数据，可能导致插入失败（若某列为NOT NULL）。举例2NF里原来的表，若只有<code>Department Id</code>和<code>Office Location</code>，就无法插入</li><li>更新问题： 当更新某个字段时，需要更新其它列。举例2NF的表，当更新Pune时， 第1列和第4列都要更新</li><li>删除问题： 当删除某些属性时，其他属性也要删除， 举例3NF原来的表，当删除SQL课程时，学生Alex的信息也会丢失</li></ul><h3 id="3-5NF：-BCNF"><a href="#3-5NF：-BCNF" class="headerlink" title="3.5NF： BCNF"></a>3.5NF： BCNF</h3><p>3.5范式用于解决3范式遗留问题<br>例如</p><table><thead><tr><th>Student Id</th><th>Subject</th><th>Professor</th></tr></thead><tbody><tr><td>1DT15ENG01</td><td>SQL</td><td>Prof. Mishra</td></tr><tr><td>1DT15ENG02</td><td>JAVA</td><td>Prof. Anand</td></tr><tr><td>1DT15ENG02</td><td>C++</td><td>Prof. Kanthi</td></tr><tr><td>1DT15ENG03</td><td>JAVA</td><td>Prof. Anand</td></tr><tr><td>1DT15ENG04</td><td>DBMS</td><td>Prof. Lokesh</td></tr></tbody></table><p>说明：</p><ul><li>一个学生可以登记多个科目</li><li>多个老师可以教授同一个科目</li><li>每个科目会有一个老师分配给一个学生</li></ul><p>所以这个表满足3范式，因为<code>Student Id</code>和<code>Subject</code>组成了复合主键，决定了<code>Professor</code>。  </p><p>但是不满足3.5NF，因为<code>Student Id</code>和<code>Subject</code>组成了复合主键，所以<code>Subject</code>是主属性， 而存在<code>Professor</code>依赖<code>Subject</code>， 虽然<code>Subject</code>是主属性，但<code>Professor</code>是非主属性，所以不满足BCNF。</p><p>此表应改成</p><table><thead><tr><th>Student Id</th><th>Professor Id</th></tr></thead><tbody><tr><td>1DT15ENG01</td><td>1DTPF01</td></tr><tr><td>1DT15ENG02</td><td>1DTPF02</td></tr><tr><td>1DT15ENG02</td><td>1DTPF03</td></tr></tbody></table><table><thead><tr><th>Professor ID</th><th>Professor</th><th>Subject</th></tr></thead><tbody><tr><td>1DTPF01</td><td>Prof. Mishra</td><td>SQL</td></tr><tr><td>1DTPF02</td><td>Prof. Anand</td><td>JAVA</td></tr><tr><td>1DTPF03</td><td>Prof. Kanthi</td><td>C++</td></tr></tbody></table><h3 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h3><p>没有冗余数据的设计未必是好设计，有时为了效率，必须降低范式标准，适当允许保留冗余数据，以达到用空间换时间的目的。</p><p>例如订单表存在<code>商品</code>，<code>单价</code>，<code>数量</code>，<code>总价</code>， 这里总价是冗余的，因为可以通过单价和数量来求得，但总价经常需要，所以冗余可以提高效率。</p><h2 id="HAVING-和查询语句优先级"><a href="#HAVING-和查询语句优先级" class="headerlink" title="HAVING 和查询语句优先级"></a>HAVING 和查询语句优先级</h2><p>SQL查询字句类似C语言的运算符优先级， 虽然标准里没有定义优先级，但大致为以下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &gt; WHERE &gt; SELECT &gt; GROUP BY &gt; HAVING &gt; ORDER BY</span><br></pre></td></tr></table></figure><p>这个顺序可以帮忙理解查询语句是如何执行的，比如因为SELECT优先级低于FROM, 所有只能在FROM中定义alais在SELECT中使用，而不能在SELECT中定义alias并在FROM中使用</p><p>HAVING指令通常和GROUP一起用，因为优先级比GROUP低，所以HAVING可以计算出GROUP的值并进行筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> Grade <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(Cno) &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个语句筛选出相同Sno记录的个数&gt;3的集合</p><h2 id="VIEW和数据冗余"><a href="#VIEW和数据冗余" class="headerlink" title="VIEW和数据冗余"></a>VIEW和数据冗余</h2><p>View是一种虚拟表，可以将多表的数据关联在一起，也可以做一些冗余数据，如计算平均值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Cl_avg_age <span class="keyword">AS</span> <span class="keyword">SELECT</span> Clno, <span class="keyword">AVG</span>(Sage) <span class="keyword">AS</span> avg_age <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><h2 id="事物，存储过程和触发器"><a href="#事物，存储过程和触发器" class="headerlink" title="事物，存储过程和触发器"></a>事物，存储过程和触发器</h2><p>存储过程需要提前创建再使用。 因为存储过程中定义变量， 输入输出明确，所以让数据库操作更安全。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ap_returncount @Sno <span class="built_in">char</span>(<span class="number">7</span>) <span class="keyword">AS</span> <span class="keyword">DECLARE</span> @<span class="keyword">count</span> <span class="built_in">int</span> <span class="keyword">SELECT</span> @<span class="keyword">count</span> = <span class="built_in">Number</span> <span class="keyword">FROM</span> <span class="keyword">Class</span> <span class="keyword">WHERE</span> Clno = (<span class="keyword">SELECT</span> Clno <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sno = @Sno) <span class="keyword">RETURN</span> @<span class="keyword">count</span>;</span><br></pre></td></tr></table></figure><p>触发器是当触发条件时自动执行的命令，如当插入和更新满足条件时自动执行事物回撤。这是基于事物机制的。<br>事物可以保证多个操作的原子性， 当莫个操作不满足条件则全部<code>ROLLBACK</code>，回撤所有的操作，例如典型的转账场景，必须要扣除和增加都成功时才能成功。</p><p>但事物导致效率比较低。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_ins_upd_student <span class="keyword">ON</span> Student <span class="keyword">AFTER</span> <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">AS</span> <span class="keyword">IF</span> <span class="number">40</span> &lt; (<span class="keyword">SELECT</span> <span class="built_in">Number</span> <span class="keyword">FROM</span> <span class="keyword">Class</span> <span class="keyword">WHERE</span> Clno = (<span class="keyword">SELECT</span> Clno <span class="keyword">FROM</span> inserted )) <span class="keyword">ROLLBACK</span> <span class="keyword">TRANSACTION</span>;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.edureka.co/blog/normalization-in-sql/" target="_blank" rel="noopener">https://www.edureka.co/blog/normalization-in-sql/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库优化总结&quot;&gt;&lt;a href=&quot;#数据库优化总结&quot; class=&quot;headerlink&quot; title=&quot;数据库优化总结&quot;&gt;&lt;/a&gt;数据库优化总结&lt;/h1&gt;&lt;p&gt;这里总结了从数据库设计和sql结构两个方面的优化&lt;/p&gt;
&lt;h2 id=&quot;数据库设计范式-Norma</summary>
      
    
    
    
    
    <category term="sql" scheme="https://energygreek.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>mutex error</title>
    <link href="https://energygreek.github.io/2022/01/25/mutex-error/"/>
    <id>https://energygreek.github.io/2022/01/25/mutex-error/</id>
    <published>2022-01-25T06:51:37.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记一次单元测试用例时失败，且出现奇怪的报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpp.c:63: __pthread_tpp_change_priority: Assertion &#96;new_prio &#x3D;&#x3D; -1 ||(new_prio &gt;&#x3D; __sched_fifo_min_prio &amp;&amp; new_prio &lt;&#x3D;__sched_fifo_max_prio)&#39; failed</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>函数定义如下，原因是下面的第一个assert条件不成立，new_prio != -1。这个函数的注释说明了需要使用者确保调用前已初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* We only want to initialize __sched_fifo_min_prio and __sched_fifo_max_prio</span><br><span class="line">   once.  The standard solution would be similar to pthread_once, but then</span><br><span class="line">   readers would need to use an acquire fence.  In this specific case,</span><br><span class="line">   initialization is comprised of just idempotent writes to two variables</span><br><span class="line">   that have an initial value of -1.  Therefore, we can treat each variable as</span><br><span class="line">   a separate, at-least-once initialized value.  This enables using just</span><br><span class="line">   relaxed MO loads and stores, but requires that consumers check for</span><br><span class="line">   initialization of each value that is to be used; see</span><br><span class="line">   __pthread_tpp_change_priority for an example.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_tpp_change_priority (<span class="keyword">int</span> previous_prio, <span class="keyword">int</span> new_prio)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">self</span> = <span class="title">THREAD_SELF</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">priority_protection_data</span> *<span class="title">tpp</span> = <span class="title">THREAD_GETMEM</span> (<span class="title">self</span>, <span class="title">tpp</span>);</span></span><br><span class="line">  <span class="keyword">int</span> fifo_min_prio = atomic_load_relaxed (&amp;__sched_fifo_min_prio);</span><br><span class="line">  <span class="keyword">int</span> fifo_max_prio = atomic_load_relaxed (&amp;__sched_fifo_max_prio);</span><br><span class="line">  <span class="keyword">if</span> (tpp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See __init_sched_fifo_prio.  We need both the min and max prio,</span></span><br><span class="line"><span class="comment">         so need to check both, and run initialization if either one is</span></span><br><span class="line"><span class="comment">         not initialized.  The memory model's write-read coherence rule</span></span><br><span class="line"><span class="comment">         makes this work.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fifo_min_prio == <span class="number">-1</span> || fifo_max_prio == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          __init_sched_fifo_prio ();</span><br><span class="line">          fifo_min_prio = atomic_load_relaxed (&amp;__sched_fifo_min_prio);</span><br><span class="line">          fifo_max_prio = atomic_load_relaxed (&amp;__sched_fifo_max_prio);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span> *tpp;</span><br><span class="line">      <span class="built_in">size</span> += (fifo_max_prio - fifo_min_prio + <span class="number">1</span>)</span><br><span class="line">              * <span class="keyword">sizeof</span> (tpp-&gt;priomap[<span class="number">0</span>]);</span><br><span class="line">      tpp = <span class="built_in">calloc</span> (<span class="built_in">size</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (tpp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ENOMEM;</span><br><span class="line">      tpp-&gt;priomax = fifo_min_prio - <span class="number">1</span>;</span><br><span class="line">      THREAD_SETMEM (self, tpp, tpp);</span><br><span class="line">    &#125;</span><br><span class="line">  assert (new_prio == <span class="number">-1</span></span><br><span class="line">          || (new_prio &gt;= fifo_min_prio</span><br><span class="line">              &amp;&amp; new_prio &lt;= fifo_max_prio));</span><br><span class="line">  assert (previous_prio == <span class="number">-1</span></span><br><span class="line">          || (previous_prio &gt;= fifo_min_prio</span><br><span class="line">              &amp;&amp; previous_prio &lt;= fifo_max_prio));</span><br></pre></td></tr></table></figure><p>网上帖子的原因是给初始化mutex并设置RECURSIVE类型时，忘了对mutexattr进行初始化，导致使用了脏内存<br>即<code>pthread_mutexattr_init(&amp;mutexattr)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t mutexattr;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Set the mutex as a recursive mutex</span><br><span class="line">pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_RECURSIVE_NP);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create the mutex with the attributes set</span><br><span class="line">pthread_mutex_init(&amp;CritSec, &amp;mutexattr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; After initializing the mutex, the thread attribute can be destroyed</span><br><span class="line">pthread_mutexattr_destroy(&amp;mutexattr);</span><br></pre></td></tr></table></figure><p>总之，要在线程启动前初始化好mutex</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>这个问题其实是c++代码抛出来的，多线程执行了下面的代码，导致了上面的问题。</p><p>AppCache中有个小粒度的锁，但这个锁还未初始化就被其他线程去lock了，导致出现问题。所以要mutex最好要在线程启动前初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppCache&#123;</span><br><span class="line">std::mutex</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> app = m_app_cache.<span class="built_in">find</span>(app_path);</span><br><span class="line"><span class="keyword">if</span> (app == m_app_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="comment">// create a new monitor element</span></span><br><span class="line">  m_app_cache.insert_or_assign(app_path, <span class="built_in">std</span>::make_shared&lt;AppCache&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(app-&gt;second-&gt;cache_mutex)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://sourceware.org/legacy-ml/libc-help/2008-05/msg00072.html?utm_source=pocket_mylist" target="_blank" rel="noopener">https://sourceware.org/legacy-ml/libc-help/2008-05/msg00072.html?utm_source=pocket_mylist</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记一次单元测试用例时失败，且出现奇怪的报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    
    <category term="c/c++" scheme="https://energygreek.github.io/tags/c-c/"/>
    
    <category term="mutex" scheme="https://energygreek.github.io/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>heap sort</title>
    <link href="https://energygreek.github.io/2021/12/13/heap-sort/"/>
    <id>https://energygreek.github.io/2021/12/13/heap-sort/</id>
    <published>2021-12-13T04:28:28.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排类似选择排序，只排序未排序的部分，但堆排比较方式不同，每次只比较log(n)次<br>最终的堆排时间复杂度为O(nlogn)</p><h2 id="关键下标"><a href="#关键下标" class="headerlink" title="关键下标"></a>关键下标</h2><p>堆一般用数组来表示，但是关系为</p><ul><li>当以1为起点时，若父节点是n</li></ul><ul><li><p>左子节点=n*2</p></li><li><p>右子节点=n*2 + 1</p></li><li><p>若节点为n, 则其父节点为n/2</p></li><li><p>若元素为m个，则最后一个根节点（非叶节点）为m/2</p></li></ul><ul><li>当以0为起点时，若父节点是n</li></ul><ul><li><p>左子节点=(n+1)<em>2-1 = n</em>2 + 1</p></li><li><p>右子节点=(n+1)<em>2+1 -1 = n</em>2 + 2</p></li><li><p>若节点下标为n, 其父节点为(n+1)/2 - 1 = (n-1)/2</p></li><li><p>若元素为m个，则最后一个根节点（非叶节点）为(m+1)/2-1 = (m-1)/2</p></li></ul><p>可见，若以1为起点，要简洁很多</p><h2 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h2><ol><li>从第一个非叶子节点开始，比较父子节点中找的最值，如果需要调整则交换父子节点再递归遍历下一层：</li></ol><ul><li>建立最小堆时，每次比较出最大值，一遍之后，堆顶为最大</li><li>建立最大堆时，每次比较出最小值，一遍之后，堆顶为最小</li></ul><ol start="2"><li>比较到顶部节点时，完成第一次遍历，找到了顶部的最值</li><li>将堆顶的最值与尾部交换，遍历范围-1，然后从堆顶开始比较</li><li>重复3动作，直到范围为1</li></ol><p>3的动作类似<code>选择排序</code>，只遍历未排序的部分</p><h2 id="最大堆和最小堆"><a href="#最大堆和最小堆" class="headerlink" title="最大堆和最小堆"></a>最大堆和最小堆</h2><p>最小堆可以求得topK<strong>大</strong>的数，反过来最大堆可以求得topK<strong>小</strong>的数</p><h3 id="topK"><a href="#topK" class="headerlink" title="topK"></a>topK</h3><p>堆排序通常用来实现topK，适用于限制内存的情况。方法是建立一个堆大小为K： 先用头部K个数据建立最小堆，后续的数字与堆顶（最小）比，如果跟小则跳过，否则替换然后执行thiftdown。其时间复杂读为O)KlogK + NlogK), 只需要一次建堆，后续都是比较。空间复杂度为K。</p><p>也可以则使用分治法，将数据分为多组，每组求其top k。最后合并起来再排序，求最终的topK。 分治法可以配合线程一起使用加快速度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用最小堆来实现topK</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thiftdown</span><span class="params">(<span class="keyword">int</span> *heap, <span class="keyword">int</span> root, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = root;</span><br><span class="line">  <span class="keyword">int</span> l = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> r = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l &lt; <span class="built_in">size</span> &amp;&amp; heap[l] &gt; heap[m]) &#123;</span><br><span class="line">    m = l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; <span class="built_in">size</span> &amp;&amp; heap[r] &gt; heap[m]) &#123;</span><br><span class="line">    m = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m != root) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = heap[root];</span><br><span class="line">    heap[root] = heap[m];</span><br><span class="line">    heap[m] = tmp;</span><br><span class="line"></span><br><span class="line">    thiftdown(heap, m, <span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> *heap, <span class="keyword">int</span> root, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = root;</span><br><span class="line">  <span class="keyword">int</span> l = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> r = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l &lt; <span class="built_in">size</span> &amp;&amp; heap[l] &lt; heap[m]) &#123;</span><br><span class="line">    m = l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; <span class="built_in">size</span> &amp;&amp; heap[r] &lt; heap[m]) &#123;</span><br><span class="line">    m = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m != root) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = heap[root];</span><br><span class="line">    heap[root] = heap[m];</span><br><span class="line">    heap[m] = tmp;</span><br><span class="line"></span><br><span class="line">    adjust(heap, m, <span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> *heap, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="built_in">size</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    thiftdown(heap, i, <span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">    heap[<span class="built_in">size</span> - <span class="number">1</span>] = tmp;</span><br><span class="line">    <span class="built_in">size</span>--;</span><br><span class="line">    thiftdown(heap, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *heap, <span class="keyword">int</span> val, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (heap[<span class="number">0</span>] &gt;= val) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  heap[<span class="number">0</span>] = val;</span><br><span class="line">  adjust(heap, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">heapify(m, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">49</span>; i++) &#123;</span><br><span class="line">  add(m, n[i], <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h3 id="海量数据求topK"><a href="#海量数据求topK" class="headerlink" title="海量数据求topK"></a>海量数据求topK</h3><p>常见问题类似：</p><ol><li>求许多重复整数中，重复第K多的正整数。</li><li>求文本中重复出现的词语次数，重复第K多的”，</li><li>ip中访问最K多的”。</li></ol><p>这些问题需要多一步统计，统计出现次数，然后再使用堆来查找topK。</p><ol><li>使用数组统计，如果目标都是正整数，如问题1</li><li>使用map&lt;target, int&gt;统计，int表示出现次数，如果目标字符串，如问题2和问题3</li></ol><p>统计完成后，将目标和计数放入结构体，再使用堆来找topK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  目标</span><br><span class="line">  次数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>topK 问题除了堆排序以外，还常用快排来找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h1&gt;&lt;p&gt;堆排类似选择排序，只排序未排序的部分，但堆排比较方式不同，每次只比较log(n)次&lt;br&gt;最终的堆排时间复杂度为O(nlogn)&lt;/</summary>
      
    
    
    
    
    <category term="algoritm" scheme="https://energygreek.github.io/tags/algoritm/"/>
    
    <category term="heapsort" scheme="https://energygreek.github.io/tags/heapsort/"/>
    
  </entry>
  
  <entry>
    <title>动态算法</title>
    <link href="https://energygreek.github.io/2021/12/09/dp-programming/"/>
    <id>https://energygreek.github.io/2021/12/09/dp-programming/</id>
    <published>2021-12-09T08:01:53.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DP-四板斧"><a href="#DP-四板斧" class="headerlink" title="DP 四板斧"></a>DP 四板斧</h1><p>以跳台阶的题目为例， 题目是以每次跳1层或2层的方式跳到n台阶， 问一共有多少种跳法<br>开始我觉得这是求路径个数，而通常dp算最大或最小值， 不适用。<br>但后来换个角度想，求最大最小必须得试过所有方法才得出来的， 而将所有的试过的方法计数，就是这题的解</p><h2 id="写出递归"><a href="#写出递归" class="headerlink" title="写出递归"></a>写出递归</h2><p>dp第一步要先写出递归来， 写递归得写收敛条件<br>这里的收敛条件是当传参小于0,则说明解法失败（多跳了），返回0。 当恰好为0则解法有效返回1  </p><p>递归体就是跳1层和跳2层</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> jump(number - <span class="number">1</span>) + jump(number - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> jump(number - <span class="number">1</span>) + jump(number - <span class="number">2</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用缓存来优化递归"><a href="#用缓存来优化递归" class="headerlink" title="用缓存来优化递归"></a>用缓存来优化递归</h2><p>递归显然会重复计算， 可以用缓存计算结果来避免， 当有缓存时使用缓存，否则才去计算， 最后将结果缓存  </p><p>并且使用缓存时应该指定尾递归的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> *cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[number];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存没命中就计算</span></span><br><span class="line">  <span class="keyword">int</span> ret1 =</span><br><span class="line">      cache[number - <span class="number">1</span>] != <span class="number">-1</span> ? cache[number - <span class="number">1</span>] : jump(number - <span class="number">1</span>, cache);</span><br><span class="line">  <span class="keyword">int</span> ret2 =</span><br><span class="line">      cache[number - <span class="number">2</span>] != <span class="number">-1</span> ? cache[number - <span class="number">2</span>] : jump(number - <span class="number">2</span>, cache);</span><br><span class="line">  cache[number] = ret1 + ret2;</span><br><span class="line">  <span class="keyword">return</span> cache[number];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cache[number + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    cache[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  cache[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  cache[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> jump(number, cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归改for循环"><a href="#递归改for循环" class="headerlink" title="递归改for循环"></a>递归改for循环</h2><p>递归的调用流程是自上而下，先计算(n)-&gt;计算(n -1)-&gt;再计算(n-2) … 0<br>现在要反过来， 先计算(0)-&gt;计算(1)-&gt;计算(2) … n<br>即自下而上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 之前要初始化为了判断， 而现在显然下标大于2的值是要计算出来的，不需要读取  </span></span><br><span class="line">  <span class="comment">// 所以不需要初始化</span></span><br><span class="line">  <span class="keyword">int</span> cache[number + <span class="number">1</span>];</span><br><span class="line">  cache[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  cache[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) &#123;</span><br><span class="line">    cache[i] = cache[i - <span class="number">1</span>] + cache[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache[number];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缩小缓存大小"><a href="#缩小缓存大小" class="headerlink" title="缩小缓存大小"></a>缩小缓存大小</h2><p>仔细看， 其实每次计算只涉及最大的三个数， 所以数组并不需要那么大，只用3个单元就足够，故直接写成3个变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloorD</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> minors2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> minors1 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) &#123;</span><br><span class="line">    total = minors1 + minors2;</span><br><span class="line">    minors2 = minors1;</span><br><span class="line">    minors1 = total;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样DP解法就出来了， 这个套路是我从力扣上学到的， 非常有效简单</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上可见，你需要训练如何发现递归关系，剩下的工作就是缓存递归调用的结果，最后是将从上到下的解决思路变为从下到上。这样我们就可以用O(N)的时间复杂度去遍历  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode.com/discuss/study-guide/1490172/dynamic-programming-is-simple" target="_blank" rel="noopener">https://leetcode.com/discuss/study-guide/1490172/dynamic-programming-is-simple</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DP-四板斧&quot;&gt;&lt;a href=&quot;#DP-四板斧&quot; class=&quot;headerlink&quot; title=&quot;DP 四板斧&quot;&gt;&lt;/a&gt;DP 四板斧&lt;/h1&gt;&lt;p&gt;以跳台阶的题目为例， 题目是以每次跳1层或2层的方式跳到n台阶， 问一共有多少种跳法&lt;br&gt;开始我觉得这是求</summary>
      
    
    
    
    
    <category term="algorithm" scheme="https://energygreek.github.io/tags/algorithm/"/>
    
    <category term="DP" scheme="https://energygreek.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>应用程序的内存管理</title>
    <link href="https://energygreek.github.io/2021/11/30/memory-management/"/>
    <id>https://energygreek.github.io/2021/11/30/memory-management/</id>
    <published>2021-11-30T20:04:11.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈内存管理"><a href="#浅谈内存管理" class="headerlink" title="浅谈内存管理"></a>浅谈内存管理</h1><p>这里记录一下看书所得，应用程序的内存管理，即glibc的malloc和相关函数</p><h2 id="内存管理的重要性"><a href="#内存管理的重要性" class="headerlink" title="内存管理的重要性"></a>内存管理的重要性</h2><p>过去Linux通过默认的dlmalloc来申请内存，但不支持多线程，这导致的竞争和性能降低，而ptmalloc2支持多线程，也成为了Linux新的默认方式<br>ptmalloc2通过为每个线程单独维护一个帧，这样每个线程的申请和释放可以并行执行，但当线程过多时，线程也将共享帧。这种帧叫做<code>per thread arena</code></p><h2 id="主线程和线程的内存申请方式"><a href="#主线程和线程的内存申请方式" class="headerlink" title="主线程和线程的内存申请方式"></a>主线程和线程的内存申请方式</h2><p>主线程中使用brk来申请大块内存，其实<code>brk</code>不过是修改了寄存器的值。而且返回的大小通常要比malloc申请的多，如同测试中的在主线程中申请100个字节大小的内存，返回了132 KB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55f7b402c000-55f7b404d000 rw-p 00000000 00:00 0                          [heap]</span><br></pre></td></tr></table></figure><p>而在线程中，malloc使用mmap来申请内存，返回大小也比申请大小多，测试中的在线程中申请100字节，返回了64M的地址空间， 但只有8MB是可用的堆内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7fb738000000-7fb738021000 rw-p 00000000 00:00 0      </span><br><span class="line">7fb738021000-7fb73c000000 ---p 00000000 00:00 0</span><br></pre></td></tr></table></figure><p>主线程中申请的地址大于Data Section的地址，说明使用的<code>brk</code>，而后者申请时用了mmap，对比附录文档可以看出32位和64位区别比较大</p><h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p>主线程和线程使用不同的arena，这样主线程和线程同时申请内存时不存在竞争。但不是所有的线程都独享一份arena, arena的个数限制如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena &#x3D; 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena &#x3D; 8 * number of cores.</span><br></pre></td></tr></table></figure><p>当线程个数太多时，会公用主线程的arena</p><h3 id="main-arena-和-per-thread-arena"><a href="#main-arena-和-per-thread-arena" class="headerlink" title="main arena 和 per thread arena"></a>main arena 和 per thread arena</h3><p>main arena 指在主线程（main）中使用的，而后者是子线程中使用，两者有很大区别<br>主线程只有一块heap，所以没有heapinfo结构，而子线程有。主线程的<code>Arena header</code>是全局变量，所以存在于libc.so的Data Segment中  </p><p>线程的arena含有多个heap, 每个heap都有heapinfo结构，多个heapinfo组成链表。线程的多个heap共享一个<code>malloc_state</code> 也称为<code>Arena header</code>  </p><p><code>Arena header</code>包含了bin、top chunk等信息  </p><p>每个heap有多个chunk，每个chunk有个<code>malloc_chunk</code>结构，其管理chunk的状态和其在heap中的偏移大小，有以下几种状态</p><ul><li>Allocated chunk </li><li>Free chunk</li><li>Top chunk</li><li>Last Remainder chunk</li></ul><p>Top chunk 处于arena的顶部，在freelist没有合适大小的chunk时使用，如果Top chunk比申请的大，则又分为两部分（新Top chunk和用户申请的chunk）  </p><p>Last Remainder chunk, 是当用户请求small chunk时，会先遍历small bin和Unsorted bin， 如果都无法满足，则遍历其他bin。<br>如果找到的chunk还有剩余，则这个chunk变为<code>Last Remainder chunk</code>，且将被加入到<code>Unsorted bin</code><br>这样的好处是多次申请small chunk时，会先向<code>Unsorted bin</code>的<code>Last Remainder chunk</code>申请， 所以小内存块会集中分布在<code>Last Remainder chunk</code>，提高小块内存的局部性  </p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>当malloc的内存被free后（仅仅是例子中的100字节chunk），并不会释放给内核，而是进入到glibc的bin中，也叫做<code>freelist</code>。<br>当下次申请内存时，会从bin中查找合适的chunk，而只有当没有合适的大小时，才向内核申请。</p><p>所以bin用来保存free过的chunk, 基于chunk的大小分为</p><ul><li>Fast bin</li><li>Unsorted bin</li><li>Small bin</li><li>Large bin</li></ul><p>但不同的bin都使用链表来管理这些chunk</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>获取程序运行时的pid, 假设为949293, 那么通过以下命令可以获取程序的内存结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;949632&#x2F;maps</span><br><span class="line"># address             perms offset  dev    inode    pathname</span><br><span class="line">55f7b378a000-55f7b378b000 r--p 00000000 103:02 4727634                   &#x2F;tmp&#x2F;a.out (deleted)</span><br><span class="line">55f7b378b000-55f7b378c000 r-xp 00001000 103:02 4727634                   &#x2F;tmp&#x2F;a.out (deleted)</span><br><span class="line">55f7b378c000-55f7b378d000 r--p 00002000 103:02 4727634                   &#x2F;tmp&#x2F;a.out (deleted)</span><br><span class="line">55f7b378d000-55f7b378e000 r--p 00002000 103:02 4727634                   &#x2F;tmp&#x2F;a.out (deleted)</span><br><span class="line">55f7b378e000-55f7b378f000 rw-p 00003000 103:02 4727634                   &#x2F;tmp&#x2F;a.out (deleted)</span><br><span class="line">55f7b402c000-55f7b404d000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7f4808000000-7f4808021000 rw-p 00000000 00:00 0 </span><br><span class="line">7f4808021000-7f480c000000 ---p 00000000 00:00 0 </span><br><span class="line">7f480ea3d000-7f480ea3e000 ---p 00000000 00:00 0 </span><br><span class="line">7f480ea3e000-7f480f241000 rw-p 00000000 00:00 0 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>address 是起始地址-结束地址，差值为空间大小</li><li>perm 是指权限，分为rwx[p,s], [p,s]指最后一位可以是private或者shared, 这些能通过<code>mprotect</code>命令修改(c中的const实现)</li><li>offset 仅对mmap的区域有效，指映射偏移量</li><li>pathname 如果此区域是映射的文件，则显示文件名。如果映射的是匿名映射则显示空白, 匿名映射包括线程通过mmap申请的堆内存，而[heap]是main函数的堆 </li></ul><p>所以通过计算address可以知道glibc申请的内存情况</p><h2 id="malloc的返回值有意义吗"><a href="#malloc的返回值有意义吗" class="headerlink" title="malloc的返回值有意义吗"></a><code>malloc</code>的返回值有意义吗</h2><p>在我本机（gcc (Debian 10.2.1-6) 10.2.1 20210110 12GB）上测试了一段程序</p><ol><li>如果一次性申请13GB，malloc返回失败</li><li>如果每次只申请2GB但不释放，第10次申请（20GB）malloc返回成功</li><li>如果每次只申请2GB但不释放且<code>访问</code>，第三次申请（6GB）malloc返回成功，但访问时OOM</li></ol><p>所以说，malloc的返回值是没有太大意义的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t large) &#123;</span><br><span class="line">  char *buffer &#x3D; (char *)malloc(large);</span><br><span class="line">  if (buffer &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    printf(&quot;error!\n&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Memory allocated\n&quot;);</span><br><span class="line">  &#x2F;&#x2F;  for (size_t i &#x3D; 0; i &lt; large; i +&#x3D; 4096) &#123;</span><br><span class="line">  &#x2F;&#x2F;    buffer[i] &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F;  &#125;</span><br><span class="line">  printf(&quot;Travalse done\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  &#x2F;&#x2F; size_t large &#x3D; 1099511627776;</span><br><span class="line">  size_t large &#x3D; 13958643712;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">    foo(2147483648);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>内存管理不仅存在应用程序（或者说glibc）中，Linux内核也有内存管理。也不只有glibc的内存malloc一种实现，还有</p><ul><li>dlmalloc – General purpose allocator</li><li>ptmalloc2 – glibc</li><li>jemalloc – FreeBSD 的libc实现, 相比其他第三方，这个比较流行</li><li>tcmalloc – Google 为多线程场景开发</li><li>libumem – Solaris</li></ul><p>malloc是glibc对ptmalloc2的包装，而<code>ptmalloc2</code>是<code>dlmalloc</code>的重构，区别很大  </p><p>最后总结，glibc的malloc通过两个系统调用函数brk和mmap来向内核申请内存，但内存释放后不会归还内核，而是放到freelist等待再次被利用</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man5/proc.5.html</a><br><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank" rel="noopener">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a><br><a href="https://lemire.me/blog/2021/10/27/in-c-how-do-you-know-if-the-dynamic-allocation-succeeded/" target="_blank" rel="noopener">https://lemire.me/blog/2021/10/27/in-c-how-do-you-know-if-the-dynamic-allocation-succeeded/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浅谈内存管理&quot;&gt;&lt;a href=&quot;#浅谈内存管理&quot; class=&quot;headerlink&quot; title=&quot;浅谈内存管理&quot;&gt;&lt;/a&gt;浅谈内存管理&lt;/h1&gt;&lt;p&gt;这里记录一下看书所得，应用程序的内存管理，即glibc的malloc和相关函数&lt;/p&gt;
&lt;h2 id=&quot;内存</summary>
      
    
    
    
    
    <category term="memory" scheme="https://energygreek.github.io/tags/memory/"/>
    
    <category term="malloc" scheme="https://energygreek.github.io/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>spdlog learn</title>
    <link href="https://energygreek.github.io/2021/11/19/spdlog-learn/"/>
    <id>https://energygreek.github.io/2021/11/19/spdlog-learn/</id>
    <published>2021-11-19T01:53:49.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spdlog"><a href="#spdlog" class="headerlink" title="spdlog"></a>spdlog</h1><p>spdlog 支持多spdlog::logger, 适用与多个隔离模块的日志分别保存  </p><p>而且logger含有多个sink的vector。sink与文件对应，如果想把日志输出到多个文件，就创建多个sink  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;sink_ptr&gt; sinks_;</span><br></pre></td></tr></table></figure><p>logger和sink的级别独立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; logger级别的判断</span><br><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">inline void spdlog::logger::log(source_loc source, level::level_enum lvl, const char *fmt, const Args &amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    if (!should_log(lvl))</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; sink级别的判断</span><br><span class="line">inline void spdlog::logger::sink_it_(details::log_msg &amp;msg)</span><br><span class="line">&#123;</span><br><span class="line">#if defined(SPDLOG_ENABLE_MESSAGE_COUNTER)</span><br><span class="line">    incr_msg_counter_(msg);</span><br><span class="line">#endif</span><br><span class="line">    for (auto &amp;sink : sinks_)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sink-&gt;should_log(msg.level))</span><br><span class="line">        &#123;</span><br><span class="line">            sink-&gt;log(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以可以支持不同的级别到不同的文件，例如logger设置为trace级别， sink1 设置为info级别， sink2设置为trace级别，这样就能创建两个日志文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info.log  # 只保存info级别</span><br><span class="line">full.log  # 保存所有级别（logger级别或者sink2的级别）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spdlog&quot;&gt;&lt;a href=&quot;#spdlog&quot; class=&quot;headerlink&quot; title=&quot;spdlog&quot;&gt;&lt;/a&gt;spdlog&lt;/h1&gt;&lt;p&gt;spdlog 支持多spdlog::logger, 适用与多个隔离模块的日志分别保存  &lt;/p&gt;
&lt;p&gt;而且</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网页爬虫入门</title>
    <link href="https://energygreek.github.io/2021/11/07/build-a-spider/"/>
    <id>https://energygreek.github.io/2021/11/07/build-a-spider/</id>
    <published>2021-11-07T08:01:53.000Z</published>
    <updated>2024-02-07T09:59:29.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><p>如何做一个最简单的爬虫？ 一条bash命令爬深圳7天天气</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取7天的天气</span></span><br><span class="line">wget -q http://www.weather.com.cn/weather/101280601.shtml -O - \</span><br><span class="line">| grep <span class="string">'class="wea"\|^&lt;h1&gt;'</span>  | grep -o <span class="string">"&gt;.*&lt;"</span> | sed <span class="string">'s/&gt;//;s/&lt;//'</span> \</span><br><span class="line">| awk <span class="string">'ORS=NR%2==1?" ":"\n" &#123;print&#125;'</span>  </span><br><span class="line"></span><br><span class="line">7日（今天） 晴</span><br><span class="line">8日（明天） 晴</span><br><span class="line">9日（后天） 晴</span><br><span class="line">10日（周五） 晴</span><br><span class="line">11日（周六） 晴</span><br><span class="line">12日（周日） 晴</span><br><span class="line">13日（周一） 晴转小雨</span><br></pre></td></tr></table></figure><h3 id="这条命令如何写出来的"><a href="#这条命令如何写出来的" class="headerlink" title="这条命令如何写出来的"></a>这条命令如何写出来的</h3><ol><li>定目标，想好要爬什么，如爬深圳天气</li><li>先在浏览器访问天气网站，网址<a href="http://www.weather.com.cn/，" target="_blank" rel="noopener">http://www.weather.com.cn/，</a> 再找到深圳7天天气的网页链接为<a href="http://www.weather.com.cn/weather/101280601.shtml" target="_blank" rel="noopener">http://www.weather.com.cn/weather/101280601.shtml</a></li><li>右键菜单里选择查看网页源码，搜索天气的内容所在位置</li><li>找规律： 日期和天气的行有特定起始内容，日期这行以<code>&lt;h1&gt;</code>开头，天气这行包含<code>class=&quot;wea&quot;</code></li><li>格式化： 清除不要的内容，使用sed和awk</li></ol><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>只有这样没有意义， 不如自己在浏览器上看？ 但如果一次性查找武汉、北京、广州的天气，但网页只能查当天的，只有保存到硬盘的数据才能永远回头翻<br>或者如果想每天<code>自动</code>执行一遍呢？ 又或者如何自动发邮件提醒你带伞呢？ –都是可以的， 这需要更多耐心和学习     </p><p>但因为bash处理网页比较麻烦，而且也不是今天的主题语言。</p><h2 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h2><ul><li>python</li><li><a href="https://scrapy.org/" target="_blank" rel="noopener">scapy</a></li><li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">Beautiful Soup</a></li></ul><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python简单灵活的语法又有丰富的生态， 适合作为入门爬虫的编程语言</p><h2 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h2><p>早期使用python自带的request库， 就能简单地实现一个爬虫软件</p><h2 id="主角scrapy"><a href="#主角scrapy" class="headerlink" title="主角scrapy"></a>主角scrapy</h2><blockquote><p>An open source and collaborative framework for extracting the data you need from websites. In a fast, simple, yet extensible way.</p></blockquote><p>scrapy 是一套完整框架， 实现了爬取网站的许多细节工作，让我们不需要了解代码，就能爬网站。其开发商还提供爬虫托管服务， 可以将你的爬虫做成在线服务， 而bs只是一个库</p><p>简单介绍</p><ul><li>目录结构</li><li>配置</li></ul><h3 id="scrapy选择器"><a href="#scrapy选择器" class="headerlink" title="scrapy选择器"></a>scrapy选择器</h3><p>选择器用来指定网页的位置，scrapy支持的选择器有两种：</p><ul><li>css</li><li>xpath</li></ul><p>自己先在源码上找规律，也可以简单地使用浏览器提供的复制选择器功能  </p><p>先手动验证, 获取列表的所有详情页链接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scrapy shell <span class="string">"https://www.douban.com/group/search?cat=1013&amp;q=深圳租房"</span>  </span><br><span class="line"><span class="comment"># xpath方式</span></span><br><span class="line">response.xpath(<span class="string">'//td[has-class("td-subject")]//a/@href'</span>).getall()</span><br><span class="line"><span class="comment"># css方式</span></span><br><span class="line">response.css(<span class="string">'td.td-subject'</span>).css(<span class="string">'a::attr(href)'</span>).getall()</span><br></pre></td></tr></table></figure><p>先手动验证, 获得下一页</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.css(<span class="string">'span.next'</span>).css(<span class="string">'a::attr(href)'</span>).get()</span><br><span class="line"><span class="comment"># 控制台-&gt;‘Copy CSS Selector’</span></span><br><span class="line"><span class="comment"># .next &gt; a:nth-child(2)</span></span><br><span class="line">response.css(<span class="string">'.next &gt; a::attr(href)'</span>).get()</span><br></pre></td></tr></table></figure><p><a href="https://parsel.readthedocs.io/en/latest/usage.html#learning-css-and-xpath" target="_blank" rel="noopener">详细</a></p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>爬到的数据可能乱和重复， 可以加个<code>清洗</code>的步骤， 在爬到数据后对数据过滤，删除不要的数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除重复条目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplicatesPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ids_seen = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">'title_digist'</span>] <span class="keyword">in</span> self.ids_seen:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">"Duplicate item found: %s"</span> % item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.ids_seen.add(item[<span class="string">'title_digist'</span>])</span><br><span class="line">            <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h2 id="具体项目-爬豆瓣租房"><a href="#具体项目-爬豆瓣租房" class="headerlink" title="具体项目 爬豆瓣租房"></a>具体项目 爬豆瓣租房</h2><h2 id="使用爬虫清理百度搜索结果"><a href="#使用爬虫清理百度搜索结果" class="headerlink" title="使用爬虫清理百度搜索结果"></a>使用爬虫清理百度搜索结果</h2><p>百度搜索的有效结果只占少部分，其他是广告，视频和推荐词  </p><p>用爬虫来提取有效结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标题</span></span><br><span class="line">response.css(<span class="string">'#content_left &gt; div.result'</span>).css(<span class="string">'a:nth-child(1)::text'</span>).getall()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">response.css(<span class="string">'#content_left &gt; div.result'</span>).css(<span class="string">'a:nth-child(1)::attr(href)'</span>).get()</span><br></pre></td></tr></table></figure><h2 id="部署成在线服务"><a href="#部署成在线服务" class="headerlink" title="部署成在线服务"></a>部署成在线服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pip install shub</span><br><span class="line"></span><br><span class="line">shub login</span><br><span class="line">Insert your Zyte Scrapy Cloud API Key: &lt;API_KEY&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deploy the spider to Zyte Scrapy Cloud</span></span><br><span class="line">shub deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Schedule the spider for execution</span></span><br><span class="line">shub schedule blogspider </span><br><span class="line">Spider blogspider scheduled, watch it running here:</span><br><span class="line">https://app.zyte.com/p/26731/job/1/8</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the scraped data</span></span><br><span class="line">shub items 26731/1/8</span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>不是所有页面都能像豆瓣这样简单直接访问，有的需要登陆，这时需要设置cookie<br>可将浏览器的访问的请求复制为curl请求，再将curl请求转换为scrapy请求, 有工具<a href="https://michael-shub.github.io/curl2scrapy/" target="_blank" rel="noopener">curl2scrapy</a></p><p>爬携程机票，但这样只能看最新或者最便宜的机票，无法自动订票</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'https://flights.ctrip.com/international/search/api/lowprice/calendar/getCalendarDetailList?v=0.4625948281116462'</span> -H <span class="string">'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0'</span> -H <span class="string">'Accept: application/json'</span> -H <span class="string">'Accept-Language: zh-CN,en-US;q=0.5'</span> --compressed -H <span class="string">'Content-Type: application/json;charset=utf-8'</span> -H <span class="string">'transactionID: 0feb04e3db5648acb409a9efaf68eb99'</span> -H <span class="string">'scope: d'</span> -H <span class="string">'Cache-Control: no-cache'</span> -H <span class="string">'Origin: https://flights.ctrip.com'</span> -H <span class="string">'Connection: keep-alive'</span> -H <span class="string">'Referer: https://flights.ctrip.com/online/list/oneway-wuh0-szx?_=1&amp;depdate=2021-12-08&amp;cabin=y_s&amp;adult=1&amp;searchid=j1043107111-1628648957090-97788Tk-0&amp;containstax=1'</span> -H <span class="string">'Cookie: _bfa=1.1638949895953.3tfx42.1.1638949895953.1638949895953.1.2; _bfs=1.2; FlightIntl=Search=[%22WUH|%E6%AD%A6%E6%B1%89(%E5%A4%A9%E6%B2%B3%E5%9B%BD%E9%99%85%E6%9C%BA%E5%9C%BA)(WUH)|477|WUH|WUH|480%22%2C%22SZX|%E6%B7%B1%E5%9C%B3(SZX)|30|SZX|480%22%2C%222021-12-09%22]; _RF1=116.30.223.163; _RSG=mtaCn0GabiBpwk2uaRD22A; _RDG=28d46524d5c5f727d530fed50e21ed2094; _RGUID=bb259100-3132-4df0-a082-35b9380aeeb3; _bfaStatus=send; MKT_Pagesource=PC; _bfaStatusPVSend=1; _bfi=p1%3D10320673302%26p2%3D10320673302%26v1%3D2%26v2%3D1'</span> -H <span class="string">'Sec-GPC: 1'</span> -H <span class="string">'TE: Trailers'</span> --data-raw <span class="string">'&#123;"cabin":"Y_S","flightWay":"S","flightSegmentList":[&#123;"arrivalCityCode":"SZX","departureCityCode":"WUH","departureDate":"2021-12-08"&#125;]&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="代理ip"><a href="#代理ip" class="headerlink" title="代理ip"></a>代理ip</h3><p>爬取的时候莫名其妙 IP 就被网站封掉了，毕竟各大网站也不想自己的数据被轻易地爬走。<br>对于爬虫来说，为了解决封禁 IP 的问题，一个有效的方式就是使用代理，使用代理之后可以让爬虫伪装自己的真实 IP，如果使用大量的随机的代理进行爬取，那么网站就不知道是我们的爬虫一直在爬取了，这样就有效地解决了反爬的问题。</p><p><a href="https://www.abuyun.com/" target="_blank" rel="noopener">阿布云</a></p><h3 id="模拟用户代理useragent"><a href="#模拟用户代理useragent" class="headerlink" title="模拟用户代理useragent"></a>模拟用户代理useragent</h3><p>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p><p>可以使用自己浏览器的UA，也可以用百度蜘蛛的UA<a href="http://www.webkaka.com/tutorial/zhanzhang/2017/061068/" target="_blank" rel="noopener">列表</a><br>但目标网站是否允许就难说了， 需要多试一试</p><h3 id="模拟浏览器"><a href="#模拟浏览器" class="headerlink" title="模拟浏览器"></a>模拟浏览器</h3><p><a href="https://www.selenium.dev/zh-cn/" target="_blank" rel="noopener">Selenium</a> 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ～&#x2F;github&#x2F;SeleniumLogin</span><br><span class="line">python SeleniumLogin&#x2F;core&#x2F;taobao.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self, username, password, chromedriverpath, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 基本设置</span></span><br><span class="line">    browser = webdriver.Chrome(options=self.chrome_opts)</span><br><span class="line">    browser.get(self.login_url)</span><br><span class="line">    driver_wait = WebDriverWait(browser, <span class="number">60</span>)</span><br><span class="line">    <span class="comment"># 点击'亲, 请登录', 进入登录界面</span></span><br><span class="line">    button = driver_wait.until(EC.presence_of_element_located((By.CLASS_NAME, <span class="string">'h'</span>)))</span><br><span class="line">    button.click()</span><br><span class="line">    <span class="comment"># 输入用户名密码</span></span><br><span class="line">    username_sender = driver_wait.until(EC.presence_of_element_located((By.ID, <span class="string">'fm-login-id'</span>)))</span><br><span class="line">    username_sender.send_keys(username)</span><br><span class="line">    password_sender = driver_wait.until(EC.presence_of_element_located((By.ID, <span class="string">'fm-login-password'</span>)))</span><br><span class="line">    password_sender.send_keys(password)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 检查是否出现了滑动验证码</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        slider = browser.find_element_by_xpath(<span class="string">"//span[contains(@class, 'btn_slide')]"</span>)</span><br><span class="line">        <span class="keyword">if</span> slider.is_displayed():</span><br><span class="line">            ActionChains(browser).click_and_hold(on_element=slider).perform()</span><br><span class="line">            ActionChains(browser).move_by_offset(xoffset=<span class="number">258</span>, yoffset=<span class="number">0</span>).perform()</span><br><span class="line">            ActionChains(browser).pause(<span class="number">0.5</span>).release().perform()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 点击登录按钮</span></span><br><span class="line">    <span class="comment">#button = driver_wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'password-login')))</span></span><br><span class="line">    <span class="comment">#button.click()</span></span><br><span class="line">    <span class="comment"># 返回必要的数据</span></span><br><span class="line">    infos_return = &#123;<span class="string">'username'</span>: username&#125;</span><br><span class="line">    <span class="keyword">return</span> infos_return, browser</span><br></pre></td></tr></table></figure><h3 id="headless"><a href="#headless" class="headerlink" title="headless"></a>headless</h3><p><a href="https://splash.readthedocs.io/en/stable/api.html#splash-http-api" target="_blank" rel="noopener">Splash HTTP API</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://c.biancheng.net/view/2011.html" target="_blank" rel="noopener">http://c.biancheng.net/view/2011.html</a><br><a href="https://github.com/CharlesPikachu/SeleniumLogin" target="_blank" rel="noopener">https://github.com/CharlesPikachu/SeleniumLogin</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;爬虫&quot;&gt;&lt;a href=&quot;#爬虫&quot; class=&quot;headerlink&quot; title=&quot;爬虫&quot;&gt;&lt;/a&gt;爬虫&lt;/h1&gt;&lt;p&gt;如何做一个最简单的爬虫？ 一条bash命令爬深圳7天天气&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    
    <category term="webcrawler" scheme="https://energygreek.github.io/tags/webcrawler/"/>
    
  </entry>
  
  <entry>
    <title>容器命名空间</title>
    <link href="https://energygreek.github.io/2021/10/14/container-tech/"/>
    <id>https://energygreek.github.io/2021/10/14/container-tech/</id>
    <published>2021-10-14T06:33:52.000Z</published>
    <updated>2024-02-07T09:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h1><p>容器是利用’cgroup’和’namespace’ 实现软件级的虚拟化，产品有lxc和docker。不同与全虚拟化和半虚拟化，这些是硬件辅助的半虚拟化Zen(Zen也有全虚拟化)和全虚拟化kvm<br>因为容器使用主机内核，不存在特权指令翻译，所以从性能上比较，容器是最高效的，其次是kvm, Zen</p><h2 id="cgroup和namespace"><a href="#cgroup和namespace" class="headerlink" title="cgroup和namespace"></a>cgroup和namespace</h2><p>这两个是容器技术的根基，包括Docker, lxc。实际上docker开始用的lxc，后来用go重新写了libcontainer来实现控制这两个东西<br>简单来说，cgroup实现对进程组的资源的限制和监控，而namespace如同c++里面类似，实现了进程组之间的隔离</p><p>但除此之外, 虚拟化系统时则还需要rootfs支持</p><h2 id="LXC和Docker"><a href="#LXC和Docker" class="headerlink" title="LXC和Docker"></a>LXC和Docker</h2><p>lxc代码合入了内核，其原理和Docker非常类似, 不过Docker有比较丰富的全套工具和方便的api   </p><h2 id="nsenter命令的使用"><a href="#nsenter命令的使用" class="headerlink" title="nsenter命令的使用"></a>nsenter命令的使用</h2><p>容器技术都使用到了namespace, 而nsenter可以操作namespace, 进入容器内部，以下都一docker容器为例  </p><p>使用命令, 获取到容器的首进程pid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format &#39;&#123;&#123;.State.Pid&#125;&#125;&#39; containername</span><br><span class="line">3015</span><br></pre></td></tr></table></figure><p>然后可以使用nsenter来进入容器，如同<code>docker exec</code> 一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">&#x2F;home&#x2F;user</span><br><span class="line">$ sudo nsenter -t 3015 -m  pwd</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure><p><code>-m</code>表示挂载命名空间，这样就能访问docker里的进程的文件系统，所以能正确打印出容器进程的当前目录<br><code>-t</code>表示目标进程，nsenter可以获取以下命名空间。 跟通过执行<code>ls /proc/self/ns</code>所看到的差不多，这里self是命令本身pid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;mnt    the mount namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;uts    the UTS namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;ipc    the IPC namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;net    the network namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;pid    the PID namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;user   the user namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;cgroup the cgroup namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;ns&#x2F;time   the time namespace</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;root      the root directory</span><br><span class="line">&#x2F;proc&#x2F;pid&#x2F;cwd       the working directory respectively</span><br></pre></td></tr></table></figure><p>上面的每项都有对应的参数，而’-a’表示进入上面的所有命名空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;容器技术&quot;&gt;&lt;a href=&quot;#容器技术&quot; class=&quot;headerlink&quot; title=&quot;容器技术&quot;&gt;&lt;/a&gt;容器技术&lt;/h1&gt;&lt;p&gt;容器是利用’cgroup’和’namespace’ 实现软件级的虚拟化，产品有lxc和docker。不同与全虚拟化和半虚拟化</summary>
      
    
    
    
    
    <category term="docker" scheme="https://energygreek.github.io/tags/docker/"/>
    
    <category term="namespace" scheme="https://energygreek.github.io/tags/namespace/"/>
    
  </entry>
  
</feed>
